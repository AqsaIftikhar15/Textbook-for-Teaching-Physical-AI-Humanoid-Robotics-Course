<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-module-3-ai-brain/week-11-12-humanoid-dev" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">Humanoid Robot Development | Physical AI &amp; Humanoid Robotics Book</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://aqsaiftikhar15.github.io/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://aqsaiftikhar15.github.io/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://aqsaiftikhar15.github.io/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-11-12-humanoid-dev/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Humanoid Robot Development | Physical AI &amp; Humanoid Robotics Book"><meta data-rh="true" name="description" content="Kinematics, dynamics, and locomotion for humanoid robots"><meta data-rh="true" property="og:description" content="Kinematics, dynamics, and locomotion for humanoid robots"><link data-rh="true" rel="icon" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aqsaiftikhar15.github.io/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-11-12-humanoid-dev/"><link data-rh="true" rel="alternate" href="https://aqsaiftikhar15.github.io/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-11-12-humanoid-dev/" hreflang="en"><link data-rh="true" rel="alternate" href="https://aqsaiftikhar15.github.io/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-11-12-humanoid-dev/" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Humanoid Robot Development","item":"https://aqsaiftikhar15.github.io/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-11-12-humanoid-dev"}]}</script><link rel="stylesheet" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/assets/css/styles.b1ae60b0.css">
<script src="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/assets/js/runtime~main.c33b3375.js" defer="defer"></script>
<script src="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/assets/js/main.068f7974.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||"light"),document.documentElement.setAttribute("data-theme-choice",t||"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/"><div class="navbar__logo"><img src="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/img/logo.svg" alt="Robotics Book Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/img/logo.svg" alt="Robotics Book Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Physical AI &amp; Humanoid Robotics</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/">Modules</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://aqsaiftikhar15.github.io/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/"><span title="Introduction" class="categoryLinkLabel_W154">Introduction</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-1-ros2/week-1-2-intro-physical-ai/"><span title="Module 1: The Robotic Nervous System (ROS 2)" class="categoryLinkLabel_W154">Module 1: The Robotic Nervous System (ROS 2)</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-2-digital-twin/week-6-7-gazebo-unity/"><span title="Module 2: The Digital Twin (Gazebo &amp; Unity)" class="categoryLinkLabel_W154">Module 2: The Digital Twin (Gazebo &amp; Unity)</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-8-10-isaac-platform/"><span title="Module 3: The AI-Robot Brain (NVIDIA Isaac)" class="categoryLinkLabel_W154">Module 3: The AI-Robot Brain (NVIDIA Isaac)</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-8-10-isaac-platform/"><span title="NVIDIA Isaac Platform" class="linkLabel_WmDU">NVIDIA Isaac Platform</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-11-12-humanoid-dev/"><span title="Humanoid Robot Development" class="linkLabel_WmDU">Humanoid Robot Development</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-13-conversational-robotics/"><span title="Conversational Robotics Overview" class="linkLabel_WmDU">Conversational Robotics Overview</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-4-vla/week-13-vla-concepts/"><span title="Module 4: Vision-Language-Action (VLA)" class="categoryLinkLabel_W154">Module 4: Vision-Language-Action (VLA)</span></a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Module 3: The AI-Robot Brain (NVIDIA Isaac)</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Humanoid Robot Development</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Week 11: Humanoid Kinematics &amp; Dynamics</h1></header>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="introduction">Introduction<a href="#introduction" class="hash-link" aria-label="Direct link to Introduction" title="Direct link to Introduction" translate="no">​</a></h2>
<p>Humanoid kinematics and dynamics form the mathematical foundation for understanding and controlling the complex movements of human-like robots. This week explores the geometric relationships (kinematics) and force interactions (dynamics) that govern humanoid robot motion. Understanding these principles is essential for developing stable, efficient, and natural-looking robot behaviors that mimic human movement patterns.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="forward-and-inverse-kinematics">Forward and Inverse Kinematics<a href="#forward-and-inverse-kinematics" class="hash-link" aria-label="Direct link to Forward and Inverse Kinematics" title="Direct link to Forward and Inverse Kinematics" translate="no">​</a></h2>
<p>Kinematics describes the geometric relationships between joint angles and end-effector positions without considering forces. Forward kinematics computes end-effector positions from joint angles, while inverse kinematics solves for joint angles given desired end-effector positions.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="forward-kinematics">Forward Kinematics<a href="#forward-kinematics" class="hash-link" aria-label="Direct link to Forward Kinematics" title="Direct link to Forward Kinematics" translate="no">​</a></h3>
<p>Forward kinematics transforms joint space coordinates to Cartesian space:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Forward Kinematics Implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class ForwardKinematics:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, robot_model):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.robot_model = robot_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.dh_parameters = robot_model.get_dh_parameters()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_forward_kinematics(self, joint_angles):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Initialize transformation matrix as identity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transform = np.eye(4)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for i, (joint_angle, dh_params) in enumerate(zip(joint_angles, self.dh_parameters)):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Compute transformation matrix for this joint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            a, alpha, d, theta_offset = dh_params</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            theta = joint_angle + theta_offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # DH transformation matrix</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cos_theta = np.cos(theta)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sin_theta = np.sin(theta)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cos_alpha = np.cos(alpha)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sin_alpha = np.sin(alpha)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            joint_transform = np.array([</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                [cos_theta, -sin_theta * cos_alpha, sin_theta * sin_alpha, a * cos_theta],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                [sin_theta, cos_theta * cos_alpha, -cos_theta * sin_alpha, a * sin_theta],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                [0, sin_alpha, cos_alpha, d],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                [0, 0, 0, 1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Combine with previous transformations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            transform = np.dot(transform, joint_transform)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return transform  # 4x4 homogeneous transformation matrix</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_end_effector_pose(self, joint_angles, chain_name):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute pose for specific kinematic chain (arm, leg, etc.)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if chain_name == &#x27;right_arm&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            chain_joints = self.robot_model.right_arm_joints</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif chain_name == &#x27;left_arm&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            chain_joints = self.robot_model.left_arm_joints</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif chain_name == &#x27;right_leg&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            chain_joints = self.robot_model.right_leg_joints</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif chain_name == &#x27;left_leg&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            chain_joints = self.robot_model.left_leg_joints</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Extract relevant joint angles</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        relevant_angles = [joint_angles[i] for i in chain_joints]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute forward kinematics for the chain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final_transform = self.compute_forward_kinematics(relevant_angles)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Extract position and orientation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        position = final_transform[:3, 3]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        orientation_matrix = final_transform[:3, :3]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Convert rotation matrix to quaternion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        quaternion = self.rotation_matrix_to_quaternion(orientation_matrix)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;position&#x27;: position,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;orientation&#x27;: quaternion,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;transform&#x27;: final_transform</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_jacobian(self, joint_angles, end_effector_link):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute geometric Jacobian matrix</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        jacobian = np.zeros((6, len(joint_angles)))  # [linear, angular]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Get end-effector position and orientation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ee_pose = self.compute_end_effector_pose(joint_angles, end_effector_link)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ee_position = ee_pose[&#x27;position&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # For each joint, compute its contribution to end-effector velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        current_transform = np.eye(4)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for i, joint_angle in enumerate(joint_angles):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Compute transformation up to this joint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            joint_transform = self.compute_single_joint_transform(joint_angle, i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            current_transform = np.dot(current_transform, joint_transform)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Get joint position and axis in global frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            joint_position = current_transform[:3, 3]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            joint_axis = current_transform[:3, 2]  # z-axis of joint frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Linear velocity contribution</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            r = ee_position - joint_position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            jacobian[:3, i] = np.cross(joint_axis, r)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Angular velocity contribution</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            jacobian[3:, i] = joint_axis</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return jacobian</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="inverse-kinematics">Inverse Kinematics<a href="#inverse-kinematics" class="hash-link" aria-label="Direct link to Inverse Kinematics" title="Direct link to Inverse Kinematics" translate="no">​</a></h3>
<p>Inverse kinematics solves for joint angles that achieve desired end-effector positions:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Inverse Kinematics Implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class InverseKinematics:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, robot_model):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.robot_model = robot_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.forward_kinematics = ForwardKinematics(robot_model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.optimizer = OptimizationSolver()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def solve_analytical_ik(self, target_pose, chain_name):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Analytical solution for simple kinematic chains (e.g., 6-DOF arm)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if chain_name == &#x27;right_arm&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return self.solve_arm_ik(target_pose)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif chain_name == &#x27;left_arm&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return self.solve_arm_ik(target_pose)  # Similar to right arm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Fall back to numerical method for complex chains</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return self.solve_numerical_ik(target_pose, chain_name)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def solve_arm_ik(self, target_pose):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Analytical solution for 6-DOF arm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Extract target position and orientation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        target_pos = target_pose[&#x27;position&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        target_rot = target_pose[&#x27;orientation&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Step 1: Find shoulder position (wrist center position)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Move back from target by wrist-to-elbow distance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wrist_to_elbow = self.robot_model.wrist_to_elbow_length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        target_orientation_matrix = self.quaternion_to_rotation_matrix(target_rot)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        approach_vector = target_orientation_matrix[:, 2]  # z-axis (approach direction)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        shoulder_pos = target_pos - approach_vector * wrist_to_elbow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Step 2: Solve for first 3 joints (position)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        theta1 = np.arctan2(shoulder_pos[1], shoulder_pos[0])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Distance from base to shoulder in x-y plane</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        r = np.sqrt(shoulder_pos[0]**2 + shoulder_pos[1]**2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        d = shoulder_pos[2] - self.robot_model.shoulder_height</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Law of cosines for shoulder and elbow joints</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        l1 = self.robot_model.upper_arm_length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        l2 = self.robot_model.forearm_length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cos_theta3 = (r**2 + d**2 - l1**2 - l2**2) / (2 * l1 * l2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cos_theta3 = np.clip(cos_theta3, -1, 1)  # Handle numerical errors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        theta3 = np.arccos(cos_theta3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Determine elbow configuration (up or down)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        theta3 = theta3 if self.robot_model.elbow_up else -theta3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        k1 = l1 + l2 * np.cos(theta3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        k2 = l2 * np.sin(theta3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        theta2 = np.arctan2(d, r) - np.arctan2(k2, k1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Step 3: Solve for last 3 joints (orientation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute wrist orientation matrix</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wrist_orientation = self.compute_wrist_orientation(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            theta1, theta2, theta3, target_rot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Extract Euler angles for wrist joints</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        theta4, theta5, theta6 = self.matrix_to_euler(wrist_orientation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return [theta1, theta2, theta3, theta4, theta5, theta6]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def solve_numerical_ik(self, target_pose, chain_name, initial_guess=None):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Numerical solution using optimization</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        def objective_function(joint_angles):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Compute current end-effector pose</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            current_pose = self.forward_kinematics.compute_end_effector_pose(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                joint_angles, chain_name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Position error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pos_error = np.linalg.norm(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                current_pose[&#x27;position&#x27;] - target_pose[&#x27;position&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Orientation error (using quaternion distance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            quat_error = self.quaternion_distance(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                current_pose[&#x27;orientation&#x27;],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                target_pose[&#x27;orientation&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return pos_error + 0.1 * quat_error  # Weight position more heavily</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Set up constraints (joint limits)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        joint_limits = self.robot_model.get_joint_limits(chain_name)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bounds = [(lim[0], lim[1]) for lim in joint_limits]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Initial guess</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if initial_guess is None:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            initial_guess = self.robot_model.get_default_angles(chain_name)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Solve optimization problem</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result = scipy.optimize.minimize(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            objective_function,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            initial_guess,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            method=&#x27;L-BFGS-B&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bounds=bounds,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            options={&#x27;maxiter&#x27;: 1000}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if result.success and result.fun &lt; 0.01:  # Acceptable error threshold</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result.x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Return best solution found or initial guess</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result.x if result.fun &lt; 1.0 else initial_guess</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def solve_redundant_ik(self, target_pose, chain_name, joint_weights=None):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Handle redundant manipulators (more DOF than task space)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Use null-space optimization to achieve secondary objectives</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if joint_weights is None:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            joint_weights = np.ones(self.robot_model.get_num_joints(chain_name))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Primary solution using numerical IK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        primary_solution = self.solve_numerical_ik(target_pose, chain_name)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute Jacobian at primary solution</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        jacobian = self.forward_kinematics.compute_jacobian(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            primary_solution, chain_name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Null space projection</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # J# = W^(-1) * J^T * (J * W^(-1) * J^T)^(-1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # where W is diagonal matrix of joint weights</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        W = np.diag(joint_weights)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        J_weighted = np.linalg.solve(W, jacobian.T).T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        JJT_inv = np.linalg.inv(np.dot(jacobian, J_weighted.T))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        jacobian_pseudoinverse = np.dot(J_weighted.T, JJT_inv)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Null space projector: I - J# * J</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        identity = np.eye(len(primary_solution))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        null_space_projector = identity - np.dot(jacobian_pseudoinverse, jacobian)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Add null space motion for secondary objectives</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # (e.g., joint centering, obstacle avoidance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        null_space_motion = self.compute_null_space_objectives(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            primary_solution, chain_name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final_solution = primary_solution + np.dot(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            null_space_projector, null_space_motion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return final_solution</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="dynamics-and-motion-equations">Dynamics and Motion Equations<a href="#dynamics-and-motion-equations" class="hash-link" aria-label="Direct link to Dynamics and Motion Equations" title="Direct link to Dynamics and Motion Equations" translate="no">​</a></h2>
<p>Robot dynamics describes the relationship between forces, torques, and motion. Understanding dynamics is crucial for controlling robot movements and ensuring stability.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="lagrangian-dynamics">Lagrangian Dynamics<a href="#lagrangian-dynamics" class="hash-link" aria-label="Direct link to Lagrangian Dynamics" title="Direct link to Lagrangian Dynamics" translate="no">​</a></h3>
<p>The Lagrangian formulation provides a systematic way to derive equations of motion:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Lagrangian Dynamics Implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class LagrangianDynamics:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, robot_model):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.robot_model = robot_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.forward_kinematics = ForwardKinematics(robot_model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_mass_matrix(self, joint_positions):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute mass matrix M(q) using recursive Newton-Euler algorithm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n = len(joint_positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        M = np.zeros((n, n))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Get link transformations and velocities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transforms = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        velocities = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for i in range(n):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Compute transform from base to link i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            transform = self.compute_link_transform(joint_positions, i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            transforms.append(transform)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Compute link velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            velocity = self.compute_link_velocity(joint_positions, joint_positions, i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            velocities.append(velocity)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute mass matrix elements</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for i in range(n):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for j in range(n):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                M[i, j] = self.compute_inertia_interaction(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    transforms[i], velocities[i],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    transforms[j], velocities[j]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return M</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_coriolis_matrix(self, joint_positions, joint_velocities):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute Coriolis and centrifugal forces matrix C(q, q_dot)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n = len(joint_positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C = np.zeros((n, n))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Use Christoffel symbols to compute Coriolis terms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        M = self.compute_mass_matrix(joint_positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for i in range(n):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for j in range(n):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                c_sum = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for k in range(n):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    # Christoffel symbol of the first kind</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    christoffel = self.compute_christoffel_symbol(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        M, i, j, k, joint_positions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    c_sum += christoffel * joint_velocities[k]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                C[i, j] = c_sum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return C</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_gravity_vector(self, joint_positions):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute gravity vector G(q)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n = len(joint_positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        G = np.zeros(n)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Transform gravity vector to each link&#x27;s frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gravity = np.array([0, 0, -9.81])  # Gravity in world frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for i in range(n):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Get link transformation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            transform = self.compute_link_transform(joint_positions, i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Transform gravity to link frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            gravity_link = np.dot(transform[:3, :3].T, gravity)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Compute gravity torque contribution</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            link_mass = self.robot_model.links[i].mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            link_com = self.robot_model.links[i].center_of_mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Gravity force at center of mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            gravity_force = link_mass * gravity_link</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Torque due to gravity force</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            jacobian = self.compute_link_jacobian(joint_positions, i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            gravity_torque = np.dot(jacobian.T[:3, :], gravity_force)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            G += gravity_torque</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return G</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_inverse_dynamics(self, joint_positions, joint_velocities, joint_accelerations):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute required joint torques using inverse dynamics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # τ = M(q)q_ddot + C(q, q_dot)q_dot + G(q) + F_ext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Mass matrix term</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        M = self.compute_mass_matrix(joint_positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mass_term = np.dot(M, joint_accelerations)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Coriolis and centrifugal term</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C = self.compute_coriolis_matrix(joint_positions, joint_velocities)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        coriolis_term = np.dot(C, joint_velocities)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Gravity term</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        G = self.compute_gravity_vector(joint_positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # External forces (optional)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        F_ext = self.compute_external_forces(joint_positions, joint_velocities)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Total required torque</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        torques = mass_term + coriolis_term + G + F_ext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return torques</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_forward_dynamics(self, joint_positions, joint_velocities, joint_torques):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute joint accelerations from applied torques</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # M(q)q_ddot = τ - C(q, q_dot)q_dot - G(q) - F_ext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute dynamics matrices</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        M = self.compute_mass_matrix(joint_positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C = self.compute_coriolis_matrix(joint_positions, joint_velocities)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        G = self.compute_gravity_vector(joint_positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        F_ext = self.compute_external_forces(joint_positions, joint_velocities)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute acceleration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bias_term = np.dot(C, joint_velocities) + G + F_ext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        acceleration = np.linalg.solve(M, joint_torques - bias_term)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return acceleration</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="recursive-newton-euler-algorithm">Recursive Newton-Euler Algorithm<a href="#recursive-newton-euler-algorithm" class="hash-link" aria-label="Direct link to Recursive Newton-Euler Algorithm" title="Direct link to Recursive Newton-Euler Algorithm" translate="no">​</a></h3>
<p>The RNEA provides an efficient way to compute inverse dynamics:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Recursive Newton-Euler Algorithm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class RecursiveNewtonEuler:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, robot_model):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.robot_model = robot_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_inverse_dynamics_rnea(self, q, q_dot, q_ddot):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n = len(q)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Initialize variables</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v = [np.zeros(6) for _ in range(n)]  # Link velocities [angular, linear]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        a = [np.zeros(6) for _ in range(n)]  # Link accelerations [angular, linear]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        f = [np.zeros(6) for _ in range(n)]  # Link forces [torque, force]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tau = np.zeros(n)  # Joint torques</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Outward recursion (compute velocities and accelerations)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Initialize base velocity and acceleration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v[0][:3] = np.zeros(3)  # Base angular velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v[0][3:] = np.zeros(3)  # Base linear velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        a[0][:3] = np.zeros(3)  # Base angular acceleration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        a[0][3:] = np.array([0, 0, -9.81])  # Base linear acceleration (gravity)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for i in range(n):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Compute joint transformation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            T_i = self.compute_transform(q[i], i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Compute joint axis in current frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if self.robot_model.joints[i].type == &#x27;revolute&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                joint_axis = np.array([0, 0, 1])  # z-axis</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                S_i = np.hstack([joint_axis, np.cross(-self.robot_model.joints[i].offset, joint_axis)])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else:  # prismatic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                joint_axis = np.array([0, 0, 1])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                S_i = np.hstack([np.zeros(3), joint_axis])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Link velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if i == 0:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                v[i] = S_i * q_dot[i]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # Transform velocity from parent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                v[i] = np.dot(T_i, np.dot(self.transform_velocity(v[i-1]), T_i.T))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                v[i] += S_i * q_dot[i]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Link acceleration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if i == 0:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                a[i] = S_i * q_ddot[i] + np.cross(v[i][:3], S_i[3:])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # Transform acceleration from parent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                a[i] = np.dot(T_i, np.dot(self.transform_acceleration(a[i-1]), T_i.T))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                a[i] += S_i * q_ddot[i]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                a[i] += np.cross(v[i][:3], S_i[3:])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Inward recursion (compute forces and torques)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for i in range(n-1, -1, -1):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Link force</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            I_i = self.robot_model.links[i].inertia_matrix</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            m_i = self.robot_model.links[i].mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            com_i = self.robot_model.links[i].center_of_mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Compute force due to link acceleration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            f[i] = np.dot(I_i, a[i][:3]) + np.cross(v[i][:3], np.dot(I_i, v[i][:3]))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            f[i][3:] = m_i * a[i][3:] + np.cross(v[i][:3], m_i * v[i][3:])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Joint torque</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            tau[i] = np.dot(S_i, f[i])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Propagate force to parent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if i &gt; 0:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                T_i_inv = np.linalg.inv(self.compute_transform(q[i], i))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                f[i-1] = f[i-1] + np.dot(T_i_inv, np.dot(f[i], T_i_inv.T))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return tau</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_transform(self, joint_angle, link_index):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute homogeneous transformation matrix for joint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dh = self.robot_model.dh_parameters[link_index]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        a, alpha, d, theta_offset = dh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        theta = joint_angle + theta_offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transform = np.array([</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            [np.cos(theta), -np.sin(theta)*np.cos(alpha), np.sin(theta)*np.sin(alpha), a*np.cos(theta)],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            [np.sin(theta), np.cos(theta)*np.cos(alpha), -np.cos(theta)*np.sin(alpha), a*np.sin(theta)],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            [0, np.sin(alpha), np.cos(alpha), d],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            [0, 0, 0, 1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return transform</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="center-of-mass-and-stability-analysis">Center of Mass and Stability Analysis<a href="#center-of-mass-and-stability-analysis" class="hash-link" aria-label="Direct link to Center of Mass and Stability Analysis" title="Direct link to Center of Mass and Stability Analysis" translate="no">​</a></h2>
<p>Understanding center of mass dynamics is crucial for humanoid robot stability and balance control.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="center-of-mass-computation">Center of Mass Computation<a href="#center-of-mass-computation" class="hash-link" aria-label="Direct link to Center of Mass Computation" title="Direct link to Center of Mass Computation" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Center of Mass Analysis</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class CenterOfMassAnalyzer:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, robot_model):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.robot_model = robot_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.forward_kinematics = ForwardKinematics(robot_model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_center_of_mass(self, joint_positions):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute overall center of mass position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        total_mass = 0.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        weighted_sum = np.zeros(3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Get transforms for all links</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transforms = self.compute_all_link_transforms(joint_positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for link, transform in zip(self.robot_model.links, transforms):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Get link mass and center of mass in link frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            mass = link.mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            local_com = link.center_of_mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Transform local COM to world frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            world_com = np.dot(transform, np.hstack([local_com, 1]))[:3]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Accumulate weighted position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            weighted_sum += mass * world_com</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            total_mass += mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if total_mass &gt; 0:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            com_position = weighted_sum / total_mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            com_position = np.zeros(3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return com_position, total_mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_com_jacobian(self, joint_positions):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute Jacobian that maps joint velocities to COM velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n = len(joint_positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_jacobian = np.zeros((3, n))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Get transforms and masses for all links</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transforms = self.compute_all_link_transforms(joint_positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute total mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        total_mass = sum(link.mass for link in self.robot_model.links)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for i in range(n):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            weighted_velocity_sum = np.zeros(3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for j, (link, transform) in enumerate(zip(self.robot_model.links, transforms)):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # Compute velocity of link COM due to joint i motion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if j &gt;= i:  # Only joints affecting this link</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    local_com = link.center_of_mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    world_com = np.dot(transform, np.hstack([local_com, 1]))[:3]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    # Get joint axis in world frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    joint_transform = self.compute_single_joint_transform(joint_positions, i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    joint_axis_world = np.dot(joint_transform[:3, :3], np.array([0, 0, 1]))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    # Position from joint i to link COM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    joint_pos = joint_transform[:3, 3]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    r = world_com - joint_pos</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    # Velocity contribution</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    velocity_contribution = np.cross(joint_axis_world, r)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    weighted_velocity_sum += link.mass * velocity_contribution</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Normalize by total mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            com_jacobian[:, i] = weighted_velocity_sum / total_mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return com_jacobian</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_zmp(self, com_position, com_velocity, com_acceleration, support_foot_height):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute Zero Moment Point (ZMP)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # ZMP_x = com_x - (com_height - support_height) * com_acc_x / g</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # ZMP_y = com_y - (com_height - support_height) * com_acc_y / g</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        g = 9.81  # Gravity constant</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Height difference</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        height_diff = com_position[2] - support_foot_height</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # ZMP calculation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        zmp_x = com_position[0] - (height_diff * com_acceleration[0]) / g</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        zmp_y = com_position[1] - (height_diff * com_acceleration[1]) / g</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return np.array([zmp_x, zmp_y, support_foot_height])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def analyze_stability_margin(self, com_position, support_polygon):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Analyze stability based on COM position relative to support polygon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Support polygon is typically defined by feet positions when walking</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Project COM to ground plane</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_xy = com_position[:2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Check if COM is within support polygon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        is_stable = self.point_in_polygon(com_xy, support_polygon)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if is_stable:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Calculate stability margin (distance to polygon boundary)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            min_distance = float(&#x27;inf&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for edge in self.get_polygon_edges(support_polygon):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                distance = self.point_to_line_distance(com_xy, edge)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                min_distance = min(min_distance, distance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            stability_margin = min_distance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Calculate distance to nearest support point</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            min_distance = float(&#x27;inf&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for vertex in support_polygon:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                distance = np.linalg.norm(com_xy - vertex[:2])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                min_distance = min(min_distance, distance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            stability_margin = -min_distance  # Negative for unstable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;is_stable&#x27;: is_stable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;stability_margin&#x27;: stability_margin,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;com_position&#x27;: com_xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="walking-pattern-generation">Walking Pattern Generation<a href="#walking-pattern-generation" class="hash-link" aria-label="Direct link to Walking Pattern Generation" title="Direct link to Walking Pattern Generation" translate="no">​</a></h2>
<p>Generating stable walking patterns requires understanding the dynamics of bipedal locomotion.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="capture-point-and-walking-control">Capture Point and Walking Control<a href="#capture-point-and-walking-control" class="hash-link" aria-label="Direct link to Capture Point and Walking Control" title="Direct link to Capture Point and Walking Control" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Walking Pattern Generator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class WalkingPatternGenerator:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, robot_model):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.robot_model = robot_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.com_analyzer = CenterOfMassAnalyzer(robot_model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.foot_step_planner = FootstepPlanner()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def generate_walking_trajectory(self, step_length, step_width, step_height, walking_speed):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Generate walking pattern using inverted pendulum model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        trajectory = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Walking parameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_height = self.robot_model.com_height</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        omega = np.sqrt(9.81 / com_height)  # Natural frequency of inverted pendulum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Step timing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        step_duration = self.calculate_step_duration(walking_speed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        double_support_duration = 0.1  # 10% of step time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        single_support_duration = step_duration - double_support_duration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Generate steps</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        current_left_foot = np.array([0, step_width/2, 0])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        current_right_foot = np.array([0, -step_width/2, 0])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for step in range(10):  # Generate 10 steps</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Determine support foot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            is_left_support = step % 2 == 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Calculate capture point for balance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if is_left_support:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                support_foot = current_left_foot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                swing_foot = current_right_foot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                support_foot = current_right_foot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                swing_foot = current_left_foot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Calculate desired COM trajectory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            com_trajectory = self.generate_com_trajectory(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                support_foot, swing_foot, step_length,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                single_support_duration, omega</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Calculate foot trajectory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            foot_trajectory = self.generate_foot_trajectory(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                swing_foot, step_length, step_width, step_height,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                single_support_duration, double_support_duration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Combine trajectories</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            step_trajectory = self.combine_trajectories(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                com_trajectory, foot_trajectory,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                is_left_support, step_duration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            trajectory.extend(step_trajectory)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Update foot positions for next step</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if is_left_support:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                current_right_foot[0] += step_length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                current_right_foot[1] = -step_width/2 if step % 4 &lt; 2 else step_width/2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                current_left_foot[0] += step_length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                current_left_foot[1] = step_width/2 if step % 4 &lt; 2 else -step_width/2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return trajectory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def generate_com_trajectory(self, support_foot, swing_foot, step_length, duration, omega):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Generate COM trajectory using 3rd order polynomial</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # to ensure smooth transitions and satisfy boundary conditions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Initial and final COM positions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        initial_com = np.array([0, 0, self.robot_model.com_height])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final_com = np.array([step_length/2, 0, self.robot_model.com_height])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Capture point trajectory (for balance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        initial_capture = support_foot[:2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final_capture = swing_foot[:2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Time vector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t = np.linspace(0, duration, int(duration * 100))  # 100 Hz sampling</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Generate smooth trajectory using 3rd order polynomial</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_trajectory = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for time in t:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Progress (0 to 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            progress = time / duration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # 3rd order polynomial: a + bt + ct^2 + dt^3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Boundary conditions: start at initial, end at final, zero velocity at start/end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            p = (3 * progress**2 - 2 * progress**3)  # Cubic interpolation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dp = (6 * progress - 6 * progress**2) / duration  # First derivative</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ddp = (6 - 12 * progress) / (duration**2)  # Second derivative</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # COM position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            com_pos = initial_com + p * (final_com - initial_com)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # COM velocity (derivative of position)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            com_vel = dp * (final_com - initial_com)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # COM acceleration (second derivative)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            com_acc = ddp * (final_com - initial_com)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Calculate ZMP from COM dynamics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            zmp = self.calculate_zmp_from_com(com_pos, com_vel, com_acc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            com_trajectory.append({</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &#x27;time&#x27;: time,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &#x27;position&#x27;: com_pos,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &#x27;velocity&#x27;: com_vel,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &#x27;acceleration&#x27;: com_acc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &#x27;zmp&#x27;: zmp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return com_trajectory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def calculate_zmp_from_com(self, com_pos, com_vel, com_acc):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Calculate ZMP from COM dynamics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        g = 9.81</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_height = com_pos[2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # ZMP = COM - (COM_height * COM_acceleration) / g</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        zmp = com_pos[:2] - (com_height * com_acc[:2]) / g</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        zmp = np.append(zmp, [0])  # ZMP on ground plane</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return zmp</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="learning-outcomes">Learning Outcomes<a href="#learning-outcomes" class="hash-link" aria-label="Direct link to Learning Outcomes" title="Direct link to Learning Outcomes" translate="no">​</a></h2>
<p>By the end of this week, students should be able to:</p>
<ol>
<li class="">
<p><strong>Solve forward and inverse kinematics</strong> - Compute end-effector positions from joint angles and vice versa using both analytical and numerical methods.</p>
</li>
<li class="">
<p><strong>Derive and compute dynamic equations</strong> - Apply Lagrangian mechanics and the recursive Newton-Euler algorithm to compute robot dynamics.</p>
</li>
<li class="">
<p><strong>Analyze center of mass and stability</strong> - Calculate center of mass position, compute stability margins, and understand balance control principles.</p>
</li>
<li class="">
<p><strong>Generate walking patterns</strong> - Create stable walking trajectories using inverted pendulum models and capture point control.</p>
</li>
<li class="">
<p><strong>Implement kinematic and dynamic control</strong> - Apply kinematic and dynamic principles to control humanoid robot movements and maintain balance.</p>
</li>
</ol>
<hr>
<h1>Week 12: Bipedal Locomotion, Manipulation, and Human-Robot Interaction</h1>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="introduction-1">Introduction<a href="#introduction-1" class="hash-link" aria-label="Direct link to Introduction" title="Direct link to Introduction" translate="no">​</a></h2>
<p>This final week of Module 3 brings together all the concepts learned to address the most challenging aspects of humanoid robotics: stable bipedal locomotion, dexterous manipulation, and natural human-robot interaction. These capabilities represent the pinnacle of humanoid robot development, requiring sophisticated integration of perception, planning, control, and learning systems to achieve human-like mobility and interaction capabilities.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="bipedal-locomotion-control">Bipedal Locomotion Control<a href="#bipedal-locomotion-control" class="hash-link" aria-label="Direct link to Bipedal Locomotion Control" title="Direct link to Bipedal Locomotion Control" translate="no">​</a></h2>
<p>Bipedal locomotion is one of the most complex challenges in humanoid robotics, requiring precise balance control, coordinated multi-joint movements, and adaptive responses to environmental disturbances.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="balance-control-systems">Balance Control Systems<a href="#balance-control-systems" class="hash-link" aria-label="Direct link to Balance Control Systems" title="Direct link to Balance Control Systems" translate="no">​</a></h3>
<p>Maintaining balance during locomotion requires sophisticated control strategies that can handle the underactuated nature of bipedal systems:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Balance Control System</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class BalanceController:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, robot_model):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.robot_model = robot_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.com_controller = COMController()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.ankle_strategy = AnkleStrategyController()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.hip_strategy = HipStrategyController()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.waist_strategy = WaistStrategyController()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.arm_swing_controller = ArmSwingController()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def compute_balance_control(self, current_state, desired_state, dt):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Extract relevant state information</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_pos = current_state[&#x27;com_position&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_vel = current_state[&#x27;com_velocity&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_acc = current_state[&#x27;com_acceleration&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        base_orientation = current_state[&#x27;base_orientation&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        base_angular_vel = current_state[&#x27;base_angular_velocity&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        foot_positions = current_state[&#x27;foot_positions&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        zmp = current_state[&#x27;zmp&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Determine support polygon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        support_polygon = self.compute_support_polygon(foot_positions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Calculate balance error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        balance_error = self.calculate_balance_error(com_pos, support_polygon)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Select balance strategy based on situation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if abs(balance_error) &lt; 0.02:  # Small perturbation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Ankle strategy - use ankle torques for small corrections</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            balance_torques = self.ankle_strategy.compute_control(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                base_orientation, base_angular_vel, balance_error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif abs(balance_error) &lt; 0.05:  # Medium perturbation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Hip strategy - use hip and ankle coordination</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            balance_torques = self.hip_strategy.compute_control(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                com_pos, com_vel, balance_error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else:  # Large perturbation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Full body strategy - use waist, arms, and stepping</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            balance_torques = self.waist_strategy.compute_control(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                com_pos, com_vel, base_orientation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Add arm swing for additional balance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arm_torques = self.arm_swing_controller.compute_control(balance_error)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            balance_torques += arm_torques</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Consider stepping strategy if needed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if self.should_take_step(balance_error, current_state):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                step_plan = self.plan_recovery_step(balance_error, current_state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return balance_torques, step_plan</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return balance_torques, None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def calculate_balance_error(self, com_pos, support_polygon):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Calculate distance from COM projection to support polygon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_xy = com_pos[:2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.point_in_polygon(com_xy, support_polygon):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # COM is inside support polygon - positive margin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            min_distance = min([</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.point_to_edge_distance(com_xy, edge)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for edge in self.get_polygon_edges(support_polygon)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return min_distance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # COM is outside support polygon - negative margin (unstable)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            min_distance = min([</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                np.linalg.norm(com_xy - vertex[:2])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for vertex in support_polygon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -min_distance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def should_take_step(self, balance_error, state):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Determine if stepping is needed for balance recovery</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if balance_error &lt; -0.05:  # COM too far outside support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return True</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Check angular momentum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        angular_momentum = state[&#x27;base_angular_velocity&#x27;] * state[&#x27;com_height&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if abs(angular_momentum) &gt; 0.5:  # Too much angular momentum to recover with stance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return True</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Check if recovery step is feasible</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        current_support_foot = state[&#x27;current_support_foot&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.is_step_feasible(current_support_foot, balance_error):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return True</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return False</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def plan_recovery_step(self, balance_error, state):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Plan optimal recovery step location</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        current_com = state[&#x27;com_position&#x27;][:2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        current_support = state[&#x27;current_support_foot&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Calculate capture point (where COM will fall if no control applied)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_vel = state[&#x27;com_velocity&#x27;][:2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_height = state[&#x27;com_position&#x27;][2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        capture_point = current_com + com_vel * np.sqrt(com_height / 9.81)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Plan step to capture point or slightly beyond for stability</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        step_target = capture_point + 0.1 * (capture_point - current_com) / np.linalg.norm(capture_point - current_com)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Ensure step is within physical limits</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        step_target = self.constrain_step_target(step_target, current_support)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Calculate step timing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        step_duration = self.calculate_step_duration(state[&#x27;walking_speed&#x27;])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;target_position&#x27;: step_target,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;timing&#x27;: step_duration,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;foot&#x27;: &#x27;left&#x27; if state[&#x27;current_support_foot&#x27;] == &#x27;right&#x27; else &#x27;right&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="walking-pattern-generation-and-execution">Walking Pattern Generation and Execution<a href="#walking-pattern-generation-and-execution" class="hash-link" aria-label="Direct link to Walking Pattern Generation and Execution" title="Direct link to Walking Pattern Generation and Execution" translate="no">​</a></h3>
<p>Creating stable walking patterns that can adapt to different terrains and conditions:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Adaptive Walking Controller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class AdaptiveWalkingController:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, robot_model):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.robot_model = robot_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.footstep_planner = FootstepPlanner()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.trajectory_generator = TrajectoryGenerator()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.terrain_analyzer = TerrainAnalyzer()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.gait_adaptation = GaitAdaptationSystem()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def generate_adaptive_walk(self, terrain_data, desired_speed, step_adjustments):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Analyze terrain properties</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        terrain_analysis = self.terrain_analyzer.analyze(terrain_data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Adjust gait parameters based on terrain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gait_params = self.gait_adaptation.adjust_parameters(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            terrain_analysis, desired_speed, step_adjustments</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Plan footstep sequence</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        footstep_sequence = self.footstep_planner.plan_sequence(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            terrain_analysis, gait_params</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Generate walking trajectories</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        walking_trajectories = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for step in footstep_sequence:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            trajectory = self.trajectory_generator.generate_step_trajectory(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                step, gait_params, terrain_analysis</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            walking_trajectories.append(trajectory)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return walking_trajectories</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def execute_walking_step(self, current_state, next_step, gait_params):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Execute single walking step with real-time adaptation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        step_trajectory = next_step[&#x27;trajectory&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Track trajectory with feedback control</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        desired_com = step_trajectory[&#x27;com_position&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        desired_foot = step_trajectory[&#x27;foot_position&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Compute tracking errors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_error = current_state[&#x27;com_position&#x27;] - desired_com</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        foot_error = current_state[&#x27;foot_position&#x27;] - desired_foot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Apply feedback control</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        com_control = self.compute_com_feedback(com_error, current_state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        foot_control = self.compute_foot_feedback(foot_error, current_state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Combine with feedforward commands</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        total_control = self.combine_feedforward_feedback(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            step_trajectory[&#x27;feedforward_torques&#x27;],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            com_control,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            foot_control</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Apply terrain adaptation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.detect_terrain_change(current_state):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            adapted_control = self.adapt_to_terrain(total_control, current_state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return adapted_control</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return total_control</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def detect_terrain_change(self, state):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Detect terrain changes using sensor fusion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        contact_force_change = self.detect_contact_force_change(state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imu_angular_velocity_change = self.detect_angular_velocity_change(state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        foot_slip_detection = self.detect_foot_slip(state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Combine multiple indicators</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        terrain_change_score = (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            0.4 * contact_force_change +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            0.3 * imu_angular_velocity_change +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            0.3 * foot_slip_detection</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return terrain_change_score &gt; 0.5  # Threshold for terrain change detection</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def adapt_gait_to_terrain(self, current_gait, terrain_type):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Adapt gait parameters based on terrain type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        adapted_gait = current_gait.copy()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if terrain_type == &#x27;rough&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Increase step height, reduce step length, increase double support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            adapted_gait[&#x27;step_height&#x27;] *= 1.5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            adapted_gait[&#x27;step_length&#x27;] *= 0.8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            adapted_gait[&#x27;double_support_ratio&#x27;] = 0.3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            adapted_gait[&#x27;ankle_stiffness&#x27;] *= 1.2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif terrain_type == &#x27;slippery&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Reduce step length, increase contact time, adjust foot angle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            adapted_gait[&#x27;step_length&#x27;] *= 0.6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            adapted_gait[&#x27;step_width&#x27;] *= 1.2  # Wider stance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            adapted_gait[&#x27;contact_angle&#x27;] = -5  # More conservative foot placement</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif terrain_type == &#x27;stairs&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Adjust for step climbing with appropriate lifting</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            adapted_gait[&#x27;step_height&#x27;] = 0.15  # Typical stair height</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            adapted_gait[&#x27;step_length&#x27;] *= 0.7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            adapted_gait[&#x27;hip_lift_compensation&#x27;] = 0.05</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return adapted_gait</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="walking-stability-and-disturbance-rejection">Walking Stability and Disturbance Rejection<a href="#walking-stability-and-disturbance-rejection" class="hash-link" aria-label="Direct link to Walking Stability and Disturbance Rejection" title="Direct link to Walking Stability and Disturbance Rejection" translate="no">​</a></h3>
<p>Handling external disturbances and maintaining stable locomotion:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Disturbance Rejection System</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class DisturbanceRejection:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.disturbance_observer = DisturbanceObserver()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.rejection_controller = DisturbanceRejectionController()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.adaptive_filter = AdaptiveFilter()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def handle_external_disturbance(self, state, measured_torques, expected_torques):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Estimate external disturbances</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        disturbance_estimate = self.disturbance_observer.estimate(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            measured_torques, expected_torques</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Classify disturbance type and magnitude</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        disturbance_type = self.classify_disturbance(disturbance_estimate)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        disturbance_magnitude = np.linalg.norm(disturbance_estimate)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Apply appropriate rejection strategy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if disturbance_magnitude &lt; 5.0:  # Small disturbance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Use feedback control to reject</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rejection_torques = self.rejection_controller.small_disturbance(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                state, disturbance_estimate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif disturbance_magnitude &lt; 20.0:  # Medium disturbance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Use feedforward + feedback control</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rejection_torques = self.rejection_controller.medium_disturbance(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                state, disturbance_estimate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else:  # Large disturbance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Emergency response - prepare for potential fall</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rejection_torques = self.rejection_controller.large_disturbance(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                state, disturbance_estimate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Consider protective behaviors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            protective_action = self.plan_protective_action(state, disturbance_estimate)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return rejection_torques</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def classify_disturbance(self, disturbance):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Classify disturbance based on pattern recognition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if len(disturbance) &gt; 50:  # Time series analysis</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Analyze frequency content and temporal patterns</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            freq_content = np.fft.fft(disturbance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dominant_freq = np.argmax(np.abs(freq_content))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if dominant_freq &lt; 5:  # Low frequency - sustained force</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return &#x27;sustained_push&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            elif 5 &lt;= dominant_freq &lt; 50:  # Medium frequency - impact</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return &#x27;impact&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else:  # High frequency - vibration/shaking</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return &#x27;vibration&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Single measurement classification</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            magnitude = np.linalg.norm(disturbance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            direction = disturbance / magnitude if magnitude &gt; 0 else np.zeros_like(disturbance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Determine direction relative to robot orientation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if abs(direction[0]) &gt; 0.7:  # Forward/backward</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return &#x27;forward_backward_push&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            elif abs(direction[1]) &gt; 0.7:  # Lateral</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return &#x27;lateral_push&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else:  # Vertical or diagonal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return &#x27;vertical_or_diagonal&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def plan_protective_action(self, state, disturbance):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Plan protective action for large disturbances</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.is_fall_imminent(state, disturbance):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Prepare for controlled fall</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return self.prepare_controlled_fall(state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Attempt recovery</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return self.attempt_recovery(state, disturbance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def is_fall_imminent(self, state, disturbance):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Predict if fall is unavoidable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Simulate forward dynamics with disturbance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        predicted_state = self.simulate_disturbance_response(state, disturbance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Check if COM will exit capture region</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.will_com_escape_capture_region(predicted_state):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return True</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Check angular momentum limits</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.exceeds_angular_momentum_limits(predicted_state):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return True</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return False</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="dexterous-manipulation">Dexterous Manipulation<a href="#dexterous-manipulation" class="hash-link" aria-label="Direct link to Dexterous Manipulation" title="Direct link to Dexterous Manipulation" translate="no">​</a></h2>
<p>Humanoid robots must achieve human-like manipulation capabilities for effective interaction with the environment and objects.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="grasp-planning-and-execution">Grasp Planning and Execution<a href="#grasp-planning-and-execution" class="hash-link" aria-label="Direct link to Grasp Planning and Execution" title="Direct link to Grasp Planning and Execution" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Grasp Planning System</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class GraspPlanner:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, robot_model):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.robot_model = robot_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.hand_model = robot_model.hand_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.object_analyzer = ObjectAnalyzer()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.grasp_synthesizer = GraspSynthesizer()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.stability_evaluator = GraspStabilityEvaluator()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def plan_grasp(self, object_pose, object_properties):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Analyze object properties</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        object_analysis = self.object_analyzer.analyze(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            object_pose, object_properties</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Generate candidate grasps</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        candidate_grasps = self.grasp_synthesizer.generate_candidates(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            object_analysis</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Evaluate grasp stability</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stable_grasps = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for grasp in candidate_grasps:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            stability_score = self.stability_evaluator.evaluate(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                grasp, object_analysis</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if stability_score &gt; 0.7:  # Threshold for stable grasp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                grasp[&#x27;stability_score&#x27;] = stability_score</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                stable_grasps.append(grasp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Sort by stability and other criteria</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stable_grasps.sort(key=lambda g: (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            g[&#x27;stability_score&#x27;],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            g[&#x27;ease_of_implementation&#x27;],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            g[&#x27;object_alignment&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ), reverse=True)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return stable_grasps[0] if stable_grasps else None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def execute_grasp_sequence(self, grasp_plan, object_pose):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Generate approach trajectory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        approach_trajectory = self.generate_approach_trajectory(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            grasp_plan, object_pose</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Execute approach motion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for waypoint in approach_trajectory:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.move_to_waypoint(waypoint)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Monitor for contact</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if self.detect_contact():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Execute grasp closure</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.execute_grasp_closure(grasp_plan[&#x27;grasp_type&#x27;])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Verify grasp success</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.verify_grasp_success():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Lift object carefully</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lift_trajectory = self.generate_lift_trajectory(object_pose)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for waypoint in lift_trajectory:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.move_to_waypoint(waypoint)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return True</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Grasp failed, try alternative</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return False</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def generate_approach_trajectory(self, grasp_plan, object_pose):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Generate collision-free approach trajectory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        start_pose = self.get_current_hand_pose()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        grasp_pose = grasp_plan[&#x27;grasp_pose&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Offset for approach (e.g., 10cm from grasp point)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        approach_offset = grasp_plan[&#x27;approach_direction&#x27;] * 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        approach_pose = grasp_pose.copy()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        approach_pose[:3, 3] += approach_offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Plan path using RRT or other motion planning algorithm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        trajectory = self.plan_collision_free_path(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            start_pose, approach_pose, object_pose</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Add final approach to grasp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        trajectory.append(grasp_pose)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return trajectory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def execute_grasp_closure(self, grasp_type):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Execute appropriate grasp closure pattern</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if grasp_type == &#x27;precision_pinch&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Move thumb and index finger together</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.move_finger_to_position(&#x27;thumb&#x27;, 0.02)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.move_finger_to_position(&#x27;index&#x27;, 0.02)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.apply_force_control(20)  # 20N grasp force</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif grasp_type == &#x27;power_grasp&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Close all fingers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for finger in [&#x27;thumb&#x27;, &#x27;index&#x27;, &#x27;middle&#x27;, &#x27;ring&#x27;, &#x27;pinky&#x27;]:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.move_finger_to_position(finger, 0.05)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.apply_force_control(50)  # Higher force for power grasp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif grasp_type == &#x27;cylindrical&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Wrap fingers around cylindrical object</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.move_finger_to_position(&#x27;thumb&#x27;, 0.03)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.move_finger_to_position(&#x27;index&#x27;, 0.04)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.move_finger_to_position(&#x27;middle&#x27;, 0.04)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.apply_force_control(30)</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="multi-modal-manipulation">Multi-Modal Manipulation<a href="#multi-modal-manipulation" class="hash-link" aria-label="Direct link to Multi-Modal Manipulation" title="Direct link to Multi-Modal Manipulation" translate="no">​</a></h3>
<p>Integrating vision, touch, and force feedback for robust manipulation:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Multi-Modal Manipulation Controller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class MultiModalManipulation:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, robot_model):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.robot_model = robot_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.vision_system = VisionSystem()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.tactile_sensors = TactileSensorArray()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.force_control = ForceController()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.manipulation_planner = ManipulationPlanner()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def execute_vision_guided_manipulation(self, target_object, task):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Get visual feedback</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        object_pose = self.vision_system.get_object_pose(target_object)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Plan manipulation sequence</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        manipulation_sequence = self.manipulation_planner.plan_sequence(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            object_pose, task</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Execute with multi-modal feedback</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for action in manipulation_sequence:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if action[&#x27;type&#x27;] == &#x27;reach&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.execute_reach_with_vision_feedback(action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            elif action[&#x27;type&#x27;] == &#x27;grasp&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.execute_grasp_with_tactile_feedback(action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            elif action[&#x27;type&#x27;] == &#x27;manipulate&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.execute_manipulation_with_force_feedback(action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def execute_reach_with_vision_feedback(self, reach_action):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Execute reaching motion with visual servoing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        target_position = reach_action[&#x27;target_position&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        current_position = self.get_end_effector_position()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while np.linalg.norm(target_position - current_position) &gt; 0.01:  # 1cm threshold</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Get updated visual feedback</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            updated_target = self.vision_system.get_object_pose(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                reach_action[&#x27;target_object&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Adjust trajectory based on updated target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            adjusted_target = self.adjust_trajectory_for_vision_error(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                target_position, updated_target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Compute control command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            control_command = self.compute_visual_servoing_command(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                current_position, adjusted_target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Apply control</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.apply_joint_velocities(control_command)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Update current position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            current_position = self.get_end_effector_position()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def execute_grasp_with_tactile_feedback(self, grasp_action):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Execute grasp with tactile feedback for adjustment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        initial_grasp_force = grasp_action[&#x27;initial_force&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Begin grasp execution</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.apply_grasp_command(grasp_action[&#x27;grasp_pattern&#x27;])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Monitor tactile sensors during grasp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while not self.is_grasp_stable():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            tactile_data = self.tactile_sensors.get_data()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Analyze tactile feedback</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            contact_points = self.extract_contact_points(tactile_data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pressure_distribution = self.analyze_pressure_distribution(tactile_data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Adjust grasp based on tactile feedback</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if not all_contacts_stable(contact_points):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # Adjust finger positions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.adjust_finger_positions(contact_points)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if pressure_distribution_skewed(pressure_distribution):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # Adjust grasp force distribution</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.adjust_force_distribution(pressure_distribution)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Continue grasping</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.continue_grasp_execution()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def execute_manipulation_with_force_feedback(self, manipulation_action):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Execute manipulation with force control</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        task_frame = manipulation_action[&#x27;task_frame&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        desired_wrench = manipulation_action[&#x27;desired_wrench&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Transform desired wrench to end-effector frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ee_wrench = self.transform_wrench_to_ee_frame(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            desired_wrench, task_frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Execute force-controlled manipulation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while not task_complete(manipulation_action):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Measure current wrench</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            current_wrench = self.force_control.get_measured_wrench()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Compute wrench error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            wrench_error = ee_wrench - current_wrench</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Apply force control</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            force_control_command = self.compute_force_control_command(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                wrench_error, manipulation_action</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Apply position control for unconstrained directions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            position_command = self.compute_position_command(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                manipulation_action</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Combine force and position control</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            combined_command = self.combine_force_position_control(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                force_control_command, position_command</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.apply_manipulation_command(combined_command)</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="human-robot-interaction">Human-Robot Interaction<a href="#human-robot-interaction" class="hash-link" aria-label="Direct link to Human-Robot Interaction" title="Direct link to Human-Robot Interaction" translate="no">​</a></h2>
<p>Natural and intuitive interaction between humans and humanoid robots is essential for practical applications.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="social-interaction-framework">Social Interaction Framework<a href="#social-interaction-framework" class="hash-link" aria-label="Direct link to Social Interaction Framework" title="Direct link to Social Interaction Framework" translate="no">​</a></h3>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Social Interaction System</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class SocialInteractionSystem:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, robot_model):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.robot_model = robot_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.speech_recognition = SpeechRecognitionSystem()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.natural_language_processing = NaturalLanguageProcessor()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.social_behavior_engine = SocialBehaviorEngine()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.emotion_recognition = EmotionRecognitionSystem()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.gesture_recognition = GestureRecognitionSystem()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def handle_human_interaction(self, human_input):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Process different types of human input</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        interaction_elements = self.analyze_human_input(human_input)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Extract speech content</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if &#x27;speech&#x27; in interaction_elements:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            speech_content = self.speech_recognition.process(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                interaction_elements[&#x27;speech&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            intent = self.natural_language_processing.extract_intent(speech_content)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Recognize emotions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if &#x27;facial_expression&#x27; in interaction_elements:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            emotions = self.emotion_recognition.analyze(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                interaction_elements[&#x27;facial_expression&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Recognize gestures</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if &#x27;hand_gesture&#x27; in interaction_elements:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            gestures = self.gesture_recognition.analyze(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                interaction_elements[&#x27;hand_gesture&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Generate appropriate response</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        response = self.social_behavior_engine.generate_response(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            intent, emotions, gestures</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Execute response with appropriate modalities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.execute_social_response(response)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def analyze_human_input(self, input_data):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Multi-modal input analysis</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elements = {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if input_data.get(&#x27;audio&#x27;):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            elements[&#x27;speech&#x27;] = input_data[&#x27;audio&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if input_data.get(&#x27;video&#x27;):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            face_data = self.extract_face_features(input_data[&#x27;video&#x27;])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            gesture_data = self.extract_gesture_features(input_data[&#x27;video&#x27;])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if face_data:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                elements[&#x27;facial_expression&#x27;] = face_data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if gesture_data:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                elements[&#x27;hand_gesture&#x27;] = gesture_data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if input_data.get(&#x27;proximity&#x27;):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            elements[&#x27;proximity&#x27;] = input_data[&#x27;proximity&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return elements</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def generate_context_aware_response(self, context, intent, emotions):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Generate response based on context and social cues</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        response = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;speech&#x27;: &#x27;&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;gesture&#x27;: &#x27;&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;facial_expression&#x27;: &#x27;&#x27;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &#x27;action&#x27;: &#x27;&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Adjust response based on detected emotions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if &#x27;happy&#x27; in emotions:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response[&#x27;speech&#x27;] = f&quot;That sounds wonderful! {intent.response}&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response[&#x27;facial_expression&#x27;] = &#x27;smile&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif &#x27;sad&#x27; in emotions:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response[&#x27;speech&#x27;] = f&quot;I&#x27;m sorry to hear that. {intent.response}&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response[&#x27;facial_expression&#x27;] = &#x27;concerned&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif &#x27;angry&#x27; in emotions:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response[&#x27;speech&#x27;] = f&quot;I understand your concern. Let me help with {intent.request}&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response[&#x27;facial_expression&#x27;] = &#x27;attentive&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response[&#x27;speech&#x27;] = intent.response</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Add appropriate gestures</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if intent.type == &#x27;greeting&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response[&#x27;gesture&#x27;] = &#x27;wave&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif intent.type == &#x27;question&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response[&#x27;gesture&#x27;] = &#x27;point_to_self&#x27;  # Indicate listening</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif intent.type == &#x27;direction&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response[&#x27;gesture&#x27;] = &#x27;point_to_location&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Adjust based on social context</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if context.get(&#x27;formal_setting&#x27;):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response[&#x27;speech&#x27;] = self.make_response_formal(response[&#x27;speech&#x27;])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif context.get(&#x27;child_interaction&#x27;):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response[&#x27;speech&#x27;] = self.make_response_child_friendly(response[&#x27;speech&#x27;])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return response</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def execute_social_response(self, response):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Execute response using multiple modalities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if response.get(&#x27;speech&#x27;):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.speak(response[&#x27;speech&#x27;])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if response.get(&#x27;gesture&#x27;):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.perform_gesture(response[&#x27;gesture&#x27;])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if response.get(&#x27;facial_expression&#x27;):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.display_facial_expression(response[&#x27;facial_expression&#x27;])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if response.get(&#x27;action&#x27;):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.perform_action(response[&#x27;action&#x27;])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def manage_interaction_flow(self, conversation_history):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Manage turn-taking and conversation flow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.should_respond(conversation_history):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Generate and execute response</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            response = self.generate_context_aware_response(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.get_current_context(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.get_current_intent(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.get_current_emotions()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.execute_social_response(response)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif self.should_initiate_topic(conversation_history):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Initiate new topic based on context</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            topic = self.select_appropriate_topic(conversation_history)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.initiate_topic(topic)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elif self.should_maintain_attention(conversation_history):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Use attention-maintaining behaviors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.perform_attention_behavior()</span><br></span></code></pre></div></div>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="collaborative-task-execution">Collaborative Task Execution<a href="#collaborative-task-execution" class="hash-link" aria-label="Direct link to Collaborative Task Execution" title="Direct link to Collaborative Task Execution" translate="no">​</a></h3>
<p>Enabling robots to work effectively alongside humans:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Pseudocode: Collaborative Task System</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class CollaborativeTaskSystem:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self, robot_model):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.robot_model = robot_model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.task_planner = CollaborativeTaskPlanner()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.human_activity_recognizer = HumanActivityRecognizer()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.intent_predictor = IntentPredictor()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.safety_monitor = SafetyMonitor()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def execute_collaborative_task(self, task_specification, human_partner):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Plan collaborative task</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        collaborative_plan = self.task_planner.create_plan(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            task_specification, human_partner.capabilities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Monitor human activities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while not task_complete(collaborative_plan):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            human_state = self.human_activity_recognizer.get_current_state()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            human_intent = self.intent_predictor.predict(human_state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Predict human actions and adjust robot behavior</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if human_intent.action == &#x27;reach_for_object&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                robot_action = self.yield_object(human_intent.target_object)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            elif human_intent.action == &#x27;make_space&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                robot_action = self.move_out_of_way()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            elif human_intent.action == &#x27;need_help&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                robot_action = self.provide_assistance(human_intent.task)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                robot_action = self.continue_plan_execution(collaborative_plan)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Execute coordinated action</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.execute_action_with_coordination(robot_action, human_state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Monitor safety</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if not self.safety_monitor.is_safe(human_state, robot_action):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.initiate_safety_protocol()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def predict_human_intentions(self, human_state):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Predict human intentions based on observed behavior</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        features = self.extract_behavioral_features(human_state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Use machine learning model to predict intentions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intent_probabilities = self.ml_model.predict(features)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Select most likely intentions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        likely_intents = [</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            intent for intent, prob in intent_probabilities.items()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if prob &gt; 0.3  # Threshold for consideration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Rank intentions by probability and context</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ranked_intents = sorted(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            likely_intents,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            key=lambda i: intent_probabilities[i],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            reverse=True</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ranked_intents</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def coordinate_with_human(self, human_action, robot_action):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Coordinate robot action with human action to avoid conflicts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.actions_conflict(human_action, robot_action):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Resolve conflict using priority rules</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if self.robot_action_has_priority(robot_action, human_action):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # Proceed with robot action, inform human</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.inform_human_of_robot_action(robot_action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # Wait for human to complete action</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.wait_for_human_completion(human_action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # Adjust robot plan accordingly</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.adjust_robot_plan(human_action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            # Execute actions in parallel if safe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.execute_parallel_actions(human_action, robot_action)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def ensure_safe_collaboration(self, human_position, robot_motion):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Ensure robot motion doesn&#x27;t interfere with human safety</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        human_workspace = self.calculate_human_workspace(human_position)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        robot_trajectory = self.discretize_robot_trajectory(robot_motion)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for waypoint in robot_trajectory:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if self.would_interfere_with_human(waypoint, human_workspace):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # Adjust trajectory to maintain safety margin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                safe_waypoint = self.find_safe_alternative(waypoint, human_workspace)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                robot_motion = self.adjust_trajectory(robot_motion, waypoint, safe_waypoint)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return robot_motion</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="learning-outcomes-1">Learning Outcomes<a href="#learning-outcomes-1" class="hash-link" aria-label="Direct link to Learning Outcomes" title="Direct link to Learning Outcomes" translate="no">​</a></h2>
<p>By the end of this week, students should be able to:</p>
<ol>
<li class="">
<p><strong>Implement balance control systems</strong> - Design and implement sophisticated balance control algorithms that can handle various perturbations and maintain stable bipedal locomotion.</p>
</li>
<li class="">
<p><strong>Generate adaptive walking patterns</strong> - Create walking controllers that can adapt to different terrains, speeds, and environmental conditions while maintaining stability.</p>
</li>
<li class="">
<p><strong>Execute dexterous manipulation</strong> - Plan and execute complex manipulation tasks using multi-modal feedback (vision, touch, force) for robust object interaction.</p>
</li>
<li class="">
<p><strong>Design human-robot interaction systems</strong> - Create social interaction frameworks that enable natural communication and collaboration between humans and humanoid robots.</p>
</li>
<li class="">
<p><strong>Integrate locomotion, manipulation, and interaction</strong> - Combine all humanoid capabilities into cohesive systems that demonstrate human-like mobility, dexterity, and social behavior.</p>
</li>
</ol>
<hr></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col noPrint_WFHX"><a href="https://github.com/AqsaIftikhar15/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-11-12-humanoid-dev.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-8-10-isaac-platform/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">NVIDIA Isaac Platform</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-13-conversational-robotics/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Conversational Robotics Overview</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#introduction" class="table-of-contents__link toc-highlight">Introduction</a></li><li><a href="#forward-and-inverse-kinematics" class="table-of-contents__link toc-highlight">Forward and Inverse Kinematics</a><ul><li><a href="#forward-kinematics" class="table-of-contents__link toc-highlight">Forward Kinematics</a></li><li><a href="#inverse-kinematics" class="table-of-contents__link toc-highlight">Inverse Kinematics</a></li></ul></li><li><a href="#dynamics-and-motion-equations" class="table-of-contents__link toc-highlight">Dynamics and Motion Equations</a><ul><li><a href="#lagrangian-dynamics" class="table-of-contents__link toc-highlight">Lagrangian Dynamics</a></li><li><a href="#recursive-newton-euler-algorithm" class="table-of-contents__link toc-highlight">Recursive Newton-Euler Algorithm</a></li></ul></li><li><a href="#center-of-mass-and-stability-analysis" class="table-of-contents__link toc-highlight">Center of Mass and Stability Analysis</a><ul><li><a href="#center-of-mass-computation" class="table-of-contents__link toc-highlight">Center of Mass Computation</a></li></ul></li><li><a href="#walking-pattern-generation" class="table-of-contents__link toc-highlight">Walking Pattern Generation</a><ul><li><a href="#capture-point-and-walking-control" class="table-of-contents__link toc-highlight">Capture Point and Walking Control</a></li></ul></li><li><a href="#learning-outcomes" class="table-of-contents__link toc-highlight">Learning Outcomes</a></li><li><a href="#introduction-1" class="table-of-contents__link toc-highlight">Introduction</a></li><li><a href="#bipedal-locomotion-control" class="table-of-contents__link toc-highlight">Bipedal Locomotion Control</a><ul><li><a href="#balance-control-systems" class="table-of-contents__link toc-highlight">Balance Control Systems</a></li><li><a href="#walking-pattern-generation-and-execution" class="table-of-contents__link toc-highlight">Walking Pattern Generation and Execution</a></li><li><a href="#walking-stability-and-disturbance-rejection" class="table-of-contents__link toc-highlight">Walking Stability and Disturbance Rejection</a></li></ul></li><li><a href="#dexterous-manipulation" class="table-of-contents__link toc-highlight">Dexterous Manipulation</a><ul><li><a href="#grasp-planning-and-execution" class="table-of-contents__link toc-highlight">Grasp Planning and Execution</a></li><li><a href="#multi-modal-manipulation" class="table-of-contents__link toc-highlight">Multi-Modal Manipulation</a></li></ul></li><li><a href="#human-robot-interaction" class="table-of-contents__link toc-highlight">Human-Robot Interaction</a><ul><li><a href="#social-interaction-framework" class="table-of-contents__link toc-highlight">Social Interaction Framework</a></li><li><a href="#collaborative-task-execution" class="table-of-contents__link toc-highlight">Collaborative Task Execution</a></li></ul></li><li><a href="#learning-outcomes-1" class="table-of-contents__link toc-highlight">Learning Outcomes</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Modules</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-1-ros2/week-1-2-intro-physical-ai/">Module 1: The Robotic Nervous System (ROS 2)</a></li><li class="footer__item"><a class="footer__link-item" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-2-digital-twin/week-6-7-gazebo-unity/">Module 2: The Digital Twin (Gazebo &amp; Unity)</a></li><li class="footer__item"><a class="footer__link-item" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-3-ai-brain/week-8-10-isaac-platform/">Module 3: The AI-Robot Brain (NVIDIA Isaac)</a></li><li class="footer__item"><a class="footer__link-item" href="/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-4-vla/week-13-vla-concepts/">Module 4: Vision-Language-Action (VLA)</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AqsaIftikhar15/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Physical AI & Humanoid Robotics Book. Built with Docusaurus.</div></div></div></footer><div class="chatWidget_KrGq"><button class="toggleBtn_o_Si" aria-label="Toggle chat widget">🤖 <!-- -->Ask AI</button></div></div>
</body>
</html>