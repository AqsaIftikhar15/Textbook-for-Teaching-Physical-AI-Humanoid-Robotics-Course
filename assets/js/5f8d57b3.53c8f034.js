"use strict";(globalThis.webpackChunkphysical_ai_robotics_book=globalThis.webpackChunkphysical_ai_robotics_book||[]).push([[3547],{4106:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module-1-ros2/week-4-advanced-ros2","title":"Advanced ROS 2 Concepts","description":"Parameter management, launch files, and real-time control","source":"@site/docs/module-1-ros2/week-4-advanced-ros2.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/week-4-advanced-ros2","permalink":"/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/module-1-ros2/week-4-advanced-ros2","draft":false,"unlisted":false,"editUrl":"https://github.com/AqsaIftikhar15/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-1-ros2/week-4-advanced-ros2.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Advanced ROS 2 Concepts","sidebar_position":3,"description":"Parameter management, launch files, and real-time control"},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Fundamentals","permalink":"/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/module-1-ros2/week-3-ros2-fundamentals"},"next":{"title":"Robot Simulation with Gazebo and Unity","permalink":"/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/module-2-digital-twin/week-6-7-gazebo-unity"}}');var o=t(4848),r=t(8453);const i={title:"Advanced ROS 2 Concepts",sidebar_position:3,description:"Parameter management, launch files, and real-time control"},s="Week 4: Advanced ROS 2 Concepts",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Parameter Management and Configuration",id:"parameter-management-and-configuration",level:2},{value:"Parameter Architecture",id:"parameter-architecture",level:3},{value:"Parameter Files and YAML Configuration",id:"parameter-files-and-yaml-configuration",level:3},{value:"Parameter Synchronization",id:"parameter-synchronization",level:3},{value:"Launch Files and System Orchestration",id:"launch-files-and-system-orchestration",level:2},{value:"Launch File Structure",id:"launch-file-structure",level:3},{value:"Advanced Launch Concepts",id:"advanced-launch-concepts",level:3},{value:"Real-Time Control Considerations",id:"real-time-control-considerations",level:2},{value:"Real-Time Scheduling",id:"real-time-scheduling",level:3},{value:"Deterministic Behavior",id:"deterministic-behavior",level:3},{value:"Advanced Communication Patterns",id:"advanced-communication-patterns",level:2},{value:"Lifecycle Nodes",id:"lifecycle-nodes",level:3},{value:"Composition and Component Architecture",id:"composition-and-component-architecture",level:3},{value:"Performance Optimization and Profiling",id:"performance-optimization-and-profiling",level:2},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Learning Outcomes",id:"learning-outcomes",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"week-4-advanced-ros-2-concepts",children:"Week 4: Advanced ROS 2 Concepts"})}),"\n",(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(n.p,{children:"This week delves into advanced ROS 2 concepts that are critical for developing sophisticated humanoid robot control systems. We explore parameter management, system orchestration through launch files, real-time performance considerations, and advanced communication patterns. These concepts enable the development of robust, maintainable, and high-performance robotic applications that can meet the demanding requirements of humanoid robotics."}),"\n",(0,o.jsx)(n.h2,{id:"parameter-management-and-configuration",children:"Parameter Management and Configuration"}),"\n",(0,o.jsx)(n.p,{children:"Effective parameter management is crucial for configuring robot behavior, tuning control algorithms, and adapting to different operating conditions. ROS 2 provides sophisticated parameter management capabilities that support both static and dynamic configuration."}),"\n",(0,o.jsx)(n.h3,{id:"parameter-architecture",children:"Parameter Architecture"}),"\n",(0,o.jsx)(n.p,{children:"Parameters in ROS 2 can be:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Static"}),": Set at node startup and remain constant during execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dynamic"}),": Changed during runtime through parameter services"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Hierarchical"}),": Organized in namespaces for complex systems"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Pseudocode: Parameter Management System\nclass ParameterManager:\n    def __init__(self, node):\n        self.node = node\n        self.parameters = {}\n        self.parameter_descriptors = {}\n\n        # Define parameter descriptors with constraints\n        self.declare_parameters_with_descriptors()\n\n        # Register parameter callback\n        self.node.set_parameters_callback(self.parameter_callback)\n\n    def declare_parameters_with_descriptors(self):\n        # Declare parameters with type, range, and description\n        self.node.declare_parameter(\n            'control.gains.p',\n            1.0,\n            ParameterDescriptor(\n                type=ParameterType.PARAMETER_DOUBLE,\n                description='Proportional gain for PID controller',\n                floating_point_range=[FloatingPointRange(from_value=0.0, to_value=10.0, step=0.01)]\n            )\n        )\n\n        self.node.declare_parameter(\n            'safety.max_velocity',\n            1.0,\n            ParameterDescriptor(\n                type=ParameterType.PARAMETER_DOUBLE,\n                description='Maximum allowed velocity for safety',\n                floating_point_range=[FloatingPointRange(from_value=0.1, to_value=5.0, step=0.01)]\n            )\n        )\n\n    def parameter_callback(self, parameters):\n        for param in parameters:\n            if param.name in self.parameters:\n                if self.validate_parameter(param):\n                    self.parameters[param.name] = param.value\n                    self.apply_parameter_change(param.name, param.value)\n                else:\n                    return SetParametersResult(successful=False, reason=f'Invalid value for {param.name}')\n\n        return SetParametersResult(successful=True)\n\n    def validate_parameter(self, parameter):\n        # Check parameter value against constraints\n        descriptor = self.parameter_descriptors.get(parameter.name)\n        if descriptor and descriptor.floating_point_range:\n            range_info = descriptor.floating_point_range[0]\n            return range_info.from_value <= parameter.value <= range_info.to_value\n        return True\n"})}),"\n",(0,o.jsx)(n.h3,{id:"parameter-files-and-yaml-configuration",children:"Parameter Files and YAML Configuration"}),"\n",(0,o.jsx)(n.p,{children:"Parameters can be loaded from YAML files for system configuration:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"# robot_config.yaml\nrobot_controller:\n  ros__parameters:\n    control:\n      gains:\n        p: 2.5\n        i: 0.1\n        d: 0.05\n      max_velocity: 0.5\n      max_acceleration: 1.0\n\n    safety:\n      collision_threshold: 0.3\n      emergency_stop_distance: 0.1\n\n    navigation:\n      global_planner: 'nav2_navfn_planner/NavfnPlanner'\n      local_planner: 'nav2_dwb_controller/DWBLocalPlanner'\n"})}),"\n",(0,o.jsx)(n.h3,{id:"parameter-synchronization",children:"Parameter Synchronization"}),"\n",(0,o.jsx)(n.p,{children:"For complex systems with multiple nodes, parameter synchronization ensures consistent configuration:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Pseudocode: Parameter Synchronization\nclass ParameterSynchronizer:\n    def __init__(self):\n        self.parameter_store = {}\n        self.node_subscriptions = {}\n\n    def synchronize_parameter(self, param_name, new_value):\n        # Update local store\n        self.parameter_store[param_name] = new_value\n\n        # Notify all subscribed nodes\n        for node_name, publisher in self.node_subscriptions.items():\n            param_msg = ParameterSync()\n            param_msg.name = param_name\n            param_msg.value = new_value\n            param_msg.timestamp = self.get_current_time()\n            publisher.publish(param_msg)\n\n    def handle_parameter_change_request(self, request, response):\n        if self.validate_parameter_request(request):\n            self.synchronize_parameter(request.param_name, request.param_value)\n            response.success = True\n            response.message = f'Parameter {request.param_name} updated successfully'\n        else:\n            response.success = False\n            response.message = 'Parameter validation failed'\n\n        return response\n"})}),"\n",(0,o.jsx)(n.h2,{id:"launch-files-and-system-orchestration",children:"Launch Files and System Orchestration"}),"\n",(0,o.jsx)(n.p,{children:"Launch files provide a declarative way to start multiple nodes with specific configurations, parameters, and dependencies. They are essential for managing complex robotic systems with many interconnected components."}),"\n",(0,o.jsx)(n.h3,{id:"launch-file-structure",children:"Launch File Structure"}),"\n",(0,o.jsx)(n.p,{children:"Launch files are written in Python and use the launch library:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# robot_launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Declare launch arguments\n    use_sim_time = LaunchConfiguration('use_sim_time', default='false')\n    robot_name = LaunchConfiguration('robot_name', default='humanoid_robot')\n\n    # Define nodes\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        parameters=[\n            {'use_sim_time': use_sim_time},\n            PathJoinSubstitution([FindPackageShare('robot_description'), 'config', 'robot.yaml'])\n        ],\n        remappings=[\n            ('/joint_states', 'robot/joint_states')\n        ]\n    )\n\n    # Control node\n    controller_manager = Node(\n        package='controller_manager',\n        executable='ros2_control_node',\n        parameters=[\n            {'use_sim_time': use_sim_time},\n            PathJoinSubstitution([FindPackageShare('robot_control'), 'config', 'controllers.yaml'])\n        ]\n    )\n\n    # Navigation node\n    navigation_node = Node(\n        package='robot_navigation',\n        executable='navigation_server',\n        name='navigation_server',\n        parameters=[\n            PathJoinSubstitution([FindPackageShare('robot_navigation'), 'config', 'nav_params.yaml'])\n        ],\n        condition=IfCondition(LaunchConfiguration('enable_navigation', default='true'))\n    )\n\n    return LaunchDescription([\n        DeclareLaunchArgument('use_sim_time', default_value='false', description='Use simulation time'),\n        DeclareLaunchArgument('robot_name', default_value='humanoid_robot', description='Name of the robot'),\n        robot_state_publisher,\n        controller_manager,\n        navigation_node\n    ])\n"})}),"\n",(0,o.jsx)(n.h3,{id:"advanced-launch-concepts",children:"Advanced Launch Concepts"}),"\n",(0,o.jsx)(n.p,{children:"Launch files support complex orchestration patterns:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Conditional Launch"}),": Start nodes based on conditions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Launch Substitutions"}),": Dynamic parameter evaluation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Event Handling"}),": React to node lifecycle events"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Composition"}),": Group multiple nodes in a single process"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Pseudocode: Advanced Launch Configuration\nclass AdvancedLaunchManager:\n    def __init__(self):\n        self.node_groups = {}\n        self.conditions = {}\n        self.event_handlers = {}\n\n    def create_conditional_launch(self, condition, nodes):\n        # Create launch configuration that depends on conditions\n        conditional_nodes = []\n        for node in nodes:\n            if self.evaluate_condition(condition):\n                conditional_nodes.append(node)\n        return conditional_nodes\n\n    def handle_node_event(self, node_name, event_type, callback):\n        # Register event handlers for node lifecycle events\n        if node_name not in self.event_handlers:\n            self.event_handlers[node_name] = []\n        self.event_handlers[node_name].append((event_type, callback))\n\n    def compose_nodes(self, node_group_name, nodes):\n        # Group multiple nodes into a single process for performance\n        composed_node = ComposableNodeContainer(\n            name=node_group_name,\n            namespace='',\n            package='rclcpp_components',\n            executable='component_container',\n            composable_node_descriptions=[\n                ComposableNode(\n                    package='package_name',\n                    plugin='plugin_class',\n                    name=node.name,\n                    parameters=[node.parameters]\n                ) for node in nodes\n            ]\n        )\n        return composed_node\n"})}),"\n",(0,o.jsx)(n.h2,{id:"real-time-control-considerations",children:"Real-Time Control Considerations"}),"\n",(0,o.jsx)(n.p,{children:"Humanoid robots require precise timing and deterministic behavior for stable control. Real-time considerations are critical for safety and performance."}),"\n",(0,o.jsx)(n.h3,{id:"real-time-scheduling",children:"Real-Time Scheduling"}),"\n",(0,o.jsx)(n.p,{children:"ROS 2 supports real-time scheduling through various mechanisms:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"SCHED_FIFO"}),": Real-time round-robin scheduling"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"SCHED_RR"}),": Real-time first-in-first-out scheduling"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"SCHED_DEADLINE"}),": Linux deadline scheduling for hard real-time"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Pseudocode: Real-Time Control Node\nclass RealTimeController:\n    def __init__(self):\n        # Initialize real-time parameters\n        self.control_period = 0.001  # 1kHz control loop\n        self.setup_real_time_scheduling()\n\n        # Create timer with precise timing\n        self.control_timer = self.node.create_timer(\n            self.control_period,\n            self.real_time_control_callback,\n            clock=Clock(clock_type=ClockType.STEADY_TIME)\n        )\n\n    def setup_real_time_scheduling(self):\n        # Configure real-time priority\n        import os\n        import ctypes\n        from ctypes import c_int, c_ulong, POINTER\n\n        # Set process to real-time priority\n        pid = os.getpid()\n        policy = ctypes.c_int(1)  # SCHED_FIFO\n        priority = ctypes.c_int(80)  # High priority\n\n        # Use sched_setscheduler system call\n        result = ctypes.CDLL('libc.so.6').sched_setscheduler(\n            ctypes.c_int(pid),\n            policy,\n            ctypes.byref(priority)\n        )\n\n        if result != 0:\n            self.node.get_logger().warn('Failed to set real-time scheduling')\n\n    def real_time_control_callback(self):\n        # Start timing measurement\n        start_time = self.node.get_clock().now()\n\n        # Perform control calculations\n        control_commands = self.compute_control_commands()\n\n        # Publish commands\n        self.command_publisher.publish(control_commands)\n\n        # End timing measurement\n        end_time = self.node.get_clock().now()\n        execution_time = (end_time - start_time).nanoseconds / 1e9\n\n        # Check timing constraints\n        if execution_time > self.control_period * 0.8:  # 80% of period\n            self.node.get_logger().warn(f'Control loop exceeded timing: {execution_time}s')\n"})}),"\n",(0,o.jsx)(n.h3,{id:"deterministic-behavior",children:"Deterministic Behavior"}),"\n",(0,o.jsx)(n.p,{children:"Achieving deterministic behavior requires careful design:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Memory Management"}),": Avoid dynamic allocation during control loops"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Lock-Free Data Structures"}),": Minimize mutex contention"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Predictable I/O"}),": Use synchronous, bounded operations"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Interrupt Handling"}),": Minimize interrupt service routine complexity"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Pseudocode: Deterministic Control Loop\nclass DeterministicController:\n    def __init__(self):\n        # Pre-allocate all memory\n        self.sensor_buffer = [0.0] * 100  # Fixed-size buffer\n        self.command_buffer = [0.0] * 50  # Fixed-size buffer\n        self.control_history = deque(maxlen=100)  # Fixed-size history\n\n        # Lock-free communication\n        self.sensor_queue = queue.Queue(maxsize=10)\n        self.command_queue = queue.Queue(maxsize=10)\n\n    def deterministic_control_loop(self):\n        while not self.shutdown_flag:\n            # Non-blocking sensor data acquisition\n            try:\n                sensor_data = self.sensor_queue.get_nowait()\n                self.process_sensor_data(sensor_data)\n            except queue.Empty:\n                pass  # Continue with previous data\n\n            # Compute control commands without dynamic allocation\n            control_output = self.compute_control_output()\n\n            # Non-blocking command publication\n            try:\n                self.command_queue.put_nowait(control_output)\n            except queue.Full:\n                pass  # Skip this cycle if command queue is full\n\n            # Sleep for remaining time in control period\n            self.sleep_until_next_period()\n\n    def compute_control_output(self):\n        # Use only pre-allocated memory and fixed-size operations\n        output = self.command_buffer.copy()  # Use pre-allocated buffer\n\n        # Deterministic control algorithm\n        for i in range(len(output)):\n            # Simple arithmetic operations only\n            output[i] = self.gains[i] * self.error_buffer[i] + self.bias[i]\n\n        return output\n"})}),"\n",(0,o.jsx)(n.h2,{id:"advanced-communication-patterns",children:"Advanced Communication Patterns"}),"\n",(0,o.jsx)(n.p,{children:"Beyond basic topics, services, and actions, ROS 2 supports advanced communication patterns for complex robotic systems."}),"\n",(0,o.jsx)(n.h3,{id:"lifecycle-nodes",children:"Lifecycle Nodes"}),"\n",(0,o.jsx)(n.p,{children:"Lifecycle nodes provide state management for complex systems:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Pseudocode: Lifecycle Node Implementation\nfrom lifecycle_msgs.msg import State\nfrom lifecycle_msgs.srv import ChangeState\n\nclass LifecycleRobotController:\n    def __init__(self):\n        self.current_state = State.PRIMARY_STATE_UNCONFIGURED\n\n        # Register lifecycle callbacks\n        self.register_configure_callback(self.configure)\n        self.register_activate_callback(self.activate)\n        self.register_deactivate_callback(self.deactivate)\n        self.register_cleanup_callback(self.cleanup)\n        self.register_shutdown_callback(self.shutdown)\n\n    def configure(self, state):\n        # Initialize resources, load parameters\n        self.initialize_controllers()\n        self.setup_communication_interfaces()\n        return TransitionCallbackReturn.SUCCESS\n\n    def activate(self, state):\n        # Start control loops, enable actuators\n        self.start_control_loops()\n        self.enable_actuators()\n        return TransitionCallbackReturn.SUCCESS\n\n    def deactivate(self, state):\n        # Stop control loops, disable actuators\n        self.stop_control_loops()\n        self.disable_actuators()\n        return TransitionCallbackReturn.SUCCESS\n\n    def lifecycle_service_callback(self, request, response):\n        # Handle lifecycle state changes\n        if request.transition.id == Transition.TRANSITION_CONFIGURE:\n            result = self.configure(None)\n        elif request.transition.id == Transition.TRANSITION_ACTIVATE:\n            result = self.activate(None)\n        # ... other transitions\n\n        response.success = (result == TransitionCallbackReturn.SUCCESS)\n        return response\n"})}),"\n",(0,o.jsx)(n.h3,{id:"composition-and-component-architecture",children:"Composition and Component Architecture"}),"\n",(0,o.jsx)(n.p,{children:"Component architecture allows multiple nodes to run in the same process:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Pseudocode: Component Architecture\nclass ComponentManager:\n    def __init__(self):\n        # Create component container\n        self.container = rclcpp_components::ComponentManager()\n\n        # Load components dynamically\n        self.load_component('sensor_processor')\n        self.load_component('motion_controller')\n        self.load_component('perception_pipeline')\n\n    def load_component(self, component_name):\n        # Load component plugin\n        node_interface = self.container.create_component(\n            component_name,\n            'package_name::ComponentClass'\n        )\n\n        # Components share memory space but maintain separate ROS interfaces\n        return node_interface\n\n    def manage_component_lifecycle(self):\n        # Control component lifecycle through composition manager\n        for component in self.container.get_loaded_components():\n            if component.needs_reconfiguration():\n                component.deactivate()\n                component.reconfigure()\n                component.activate()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"performance-optimization-and-profiling",children:"Performance Optimization and Profiling"}),"\n",(0,o.jsx)(n.p,{children:"Optimizing ROS 2 applications requires understanding performance bottlenecks and using appropriate tools."}),"\n",(0,o.jsx)(n.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Pseudocode: Performance Monitoring\nclass PerformanceMonitor:\n    def __init__(self, node):\n        self.node = node\n        self.metrics = {}\n        self.profiler = Profiler()\n\n        # Create diagnostic publisher\n        self.diag_publisher = node.create_publisher(\n            diagnostic_msgs.msg.DiagnosticArray,\n            '/diagnostics',\n            10\n        )\n\n        # Create performance timer\n        self.diag_timer = node.create_timer(1.0, self.publish_diagnostics)\n\n    def start_profiling(self, operation_name):\n        self.profiler.start(operation_name)\n\n    def stop_profiling(self, operation_name):\n        duration = self.profiler.stop(operation_name)\n        self.record_metric(operation_name, duration)\n\n    def record_metric(self, operation_name, value):\n        if operation_name not in self.metrics:\n            self.metrics[operation_name] = []\n        self.metrics[operation_name].append(value)\n\n    def publish_diagnostics(self):\n        diag_array = diagnostic_msgs.msg.DiagnosticArray()\n        diag_array.header.stamp = self.node.get_clock().now().to_msg()\n\n        for operation_name, values in self.metrics.items():\n            if values:\n                avg_time = sum(values[-10:]) / len(values[-10:])  # Last 10 samples\n                status = diagnostic_msgs.msg.DiagnosticStatus()\n                status.name = f'{operation_name}_performance'\n                status.level = diagnostic_msgs.msg.DiagnosticStatus.OK\n\n                if avg_time > 0.05:  # Warning threshold\n                    status.level = diagnostic_msgs.msg.DiagnosticStatus.WARN\n                    status.message = f'High execution time: {avg_time:.3f}s'\n                else:\n                    status.message = f'Normal execution time: {avg_time:.3f}s'\n\n                status.values.append(KeyValue(key='average_time', value=str(avg_time)))\n                status.values.append(KeyValue(key='sample_count', value=str(len(values))))\n\n                diag_array.status.append(status)\n\n        self.diag_publisher.publish(diag_array)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(n.p,{children:"By the end of this week, students should be able to:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Manage complex parameter systems"})," - Implement parameter validation, synchronization, and configuration management for humanoid robot control systems."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Orchestrate complex robotic systems"})," - Create launch files that properly configure and coordinate multiple nodes with appropriate dependencies and conditions."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Design real-time control systems"})," - Implement deterministic control loops with proper timing constraints and real-time scheduling for humanoid robot applications."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Apply advanced communication patterns"})," - Utilize lifecycle nodes, component architecture, and other advanced ROS 2 features for robust system design."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Optimize system performance"})," - Profile and optimize ROS 2 applications to meet the demanding performance requirements of humanoid robotics."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var a=t(6540);const o={},r=a.createContext(o);function i(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);