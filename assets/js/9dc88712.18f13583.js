"use strict";(globalThis.webpackChunkphysical_ai_robotics_book=globalThis.webpackChunkphysical_ai_robotics_book||[]).push([[7539],{4390:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-1-ros2/week-3-ros2-fundamentals","title":"ROS 2 Fundamentals","description":"Overview of ROS 2 middleware architecture","source":"@site/docs/module-1-ros2/week-3-ros2-fundamentals.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/week-3-ros2-fundamentals","permalink":"/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-1-ros2/week-3-ros2-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/AqsaIftikhar15/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-1-ros2/week-3-ros2-fundamentals.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"ROS 2 Fundamentals","sidebar_position":2,"description":"Overview of ROS 2 middleware architecture"},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Physical AI","permalink":"/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-1-ros2/week-1-2-intro-physical-ai"},"next":{"title":"Advanced ROS 2 Concepts","permalink":"/Textbook-for-Teaching-Physical-AI-Humanoid-Robotics-Course/docs/module-1-ros2/week-4-advanced-ros2"}}');var r=s(4848),t=s(8453);const o={title:"ROS 2 Fundamentals",sidebar_position:2,description:"Overview of ROS 2 middleware architecture"},l="Week 3: ROS 2 Fundamentals",a={},c=[{value:"Introduction",id:"introduction",level:2},{value:"ROS 2 Architecture and Middleware Design",id:"ros-2-architecture-and-middleware-design",level:2},{value:"Client Library Architecture",id:"client-library-architecture",level:3},{value:"Node-Based Architecture",id:"node-based-architecture",level:3},{value:"Communication Patterns",id:"communication-patterns",level:3},{value:"Topics and Message Passing",id:"topics-and-message-passing",level:2},{value:"Topic Architecture",id:"topic-architecture",level:3},{value:"Quality of Service (QoS) Profiles",id:"quality-of-service-qos-profiles",level:3},{value:"Services and Request-Response Communication",id:"services-and-request-response-communication",level:2},{value:"Service Architecture",id:"service-architecture",level:3},{value:"Actions for Complex Task Management",id:"actions-for-complex-task-management",level:2},{value:"Action Architecture",id:"action-architecture",level:3},{value:"URDF and Robot Description",id:"urdf-and-robot-description",level:2},{value:"URDF Structure",id:"urdf-structure",level:3},{value:"Communication Patterns and Best Practices",id:"communication-patterns-and-best-practices",level:2},{value:"Topic vs Service vs Action Selection",id:"topic-vs-service-vs-action-selection",level:3},{value:"Design Patterns",id:"design-patterns",level:3},{value:"Learning Outcomes",id:"learning-outcomes",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"week-3-ros-2-fundamentals",children:"Week 3: ROS 2 Fundamentals"})}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(n.p,{children:'ROS 2 (Robot Operating System 2) serves as the middleware layer that enables communication between different components of a robotic system, functioning as the "nervous system" of the robot. This week explores the fundamental concepts of ROS 2, including its architecture, communication patterns, and core components. Understanding ROS 2 is essential for developing modular, scalable, and maintainable robotic applications that can coordinate sensors, actuators, and computational processes effectively.'}),"\n",(0,r.jsx)(n.h2,{id:"ros-2-architecture-and-middleware-design",children:"ROS 2 Architecture and Middleware Design"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 implements a distributed computing framework that allows different software components to communicate seamlessly across multiple processes and machines. The architecture is built on the Data Distribution Service (DDS) standard, which provides a publish-subscribe communication model with quality-of-service (QoS) controls."}),"\n",(0,r.jsx)(n.h3,{id:"client-library-architecture",children:"Client Library Architecture"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 provides client libraries that wrap DDS functionality:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"rclcpp"}),": C++ client library for performance-critical applications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"rclpy"}),": Python client library for rapid prototyping and scripting"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"rclc"}),": C client library for embedded systems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"rclnodejs"}),": JavaScript client library for web integration"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The client libraries provide a consistent API across programming languages while maintaining the underlying DDS communication infrastructure."}),"\n",(0,r.jsx)(n.h3,{id:"node-based-architecture",children:"Node-Based Architecture"}),"\n",(0,r.jsx)(n.p,{children:"The fundamental unit of computation in ROS 2 is the node:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Pseudocode: Basic ROS 2 Node Structure\nclass RobotNode:\n    def __init__(self, node_name):\n        self.node = rclpy.create_node(node_name)\n        self.publishers = {}\n        self.subscribers = {}\n        self.services = {}\n        self.actions = {}\n\n    def create_publisher(self, msg_type, topic_name, qos_profile):\n        publisher = self.node.create_publisher(msg_type, topic_name, qos_profile)\n        self.publishers[topic_name] = publisher\n        return publisher\n\n    def create_subscription(self, msg_type, topic_name, callback, qos_profile):\n        subscriber = self.node.create_subscription(msg_type, topic_name, callback, qos_profile)\n        self.subscribers[topic_name] = subscriber\n        return subscriber\n\n    def spin(self):\n        rclpy.spin(self.node)\n\n    def destroy_node(self):\n        self.node.destroy_node()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"communication-patterns",children:"Communication Patterns"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 supports multiple communication patterns:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Publish-Subscribe"}),": Asynchronous one-to-many communication"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Request-Response"}),": Synchronous client-server communication"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Action-Based"}),": Asynchronous request-response with feedback and goal management"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"topics-and-message-passing",children:"Topics and Message Passing"}),"\n",(0,r.jsx)(n.p,{children:"Topics form the backbone of ROS 2's publish-subscribe communication model, enabling asynchronous data exchange between nodes."}),"\n",(0,r.jsx)(n.h3,{id:"topic-architecture",children:"Topic Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Topics are named channels through which nodes publish and subscribe to messages:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Publishers"}),": Nodes that send messages to topics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Subscribers"}),": Nodes that receive messages from topics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Message Types"}),": Strongly typed data structures defined in .msg files"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Pseudocode: Topic Publisher Implementation\nclass SensorPublisher:\n    def __init__(self):\n        self.node = rclpy.create_node('sensor_publisher')\n        self.publisher = self.node.create_publisher(\n            sensor_msgs.msg.LaserScan,\n            'laser_scan',\n            10  // Queue size\n        )\n        self.timer = self.node.create_timer(0.1, self.publish_scan)\n\n    def publish_scan(self):\n        scan_msg = sensor_msgs.msg.LaserScan()\n        scan_msg.header.stamp = self.node.get_clock().now().to_msg()\n        scan_msg.header.frame_id = 'laser_frame'\n        scan_msg.angle_min = -1.57  // -90 degrees\n        scan_msg.angle_max = 1.57   // 90 degrees\n        scan_msg.angle_increment = 0.01\n        scan_msg.ranges = self.get_laser_data()\n\n        self.publisher.publish(scan_msg)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"quality-of-service-qos-profiles",children:"Quality of Service (QoS) Profiles"}),"\n",(0,r.jsx)(n.p,{children:"QoS profiles control the reliability and performance characteristics of topic communication:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reliability"}),": Reliable (all messages delivered) vs Best Effort (no guarantee)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Durability"}),": Volatile (new subscribers don't receive old messages) vs Transient Local"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"History"}),": Keep All vs Keep Last N messages"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deadline"}),": Maximum time between message publications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Liveliness"}),": How to detect if a publisher is still active"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Pseudocode: QoS Configuration\ndef configure_qos_profiles():\n    # High-priority control commands\n    control_qos = rclpy.qos.QoSProfile(\n        reliability=rclpy.qos.ReliabilityPolicy.RELIABLE,\n        durability=rclpy.qos.DurabilityPolicy.VOLATILE,\n        history=rclpy.qos.HistoryPolicy.KEEP_LAST,\n        depth=1  // Only keep the most recent command\n    )\n\n    # Sensor data (can tolerate some loss)\n    sensor_qos = rclpy.qos.QoSProfile(\n        reliability=rclpy.qos.ReliabilityPolicy.BEST_EFFORT,\n        durability=rclpy.qos.DurabilityPolicy.VOLATILE,\n        history=rclpy.qos.HistoryPolicy.KEEP_ALL,\n        depth=100  // Keep many sensor readings\n    )\n\n    return control_qos, sensor_qos\n"})}),"\n",(0,r.jsx)(n.h2,{id:"services-and-request-response-communication",children:"Services and Request-Response Communication"}),"\n",(0,r.jsx)(n.p,{children:"Services provide synchronous request-response communication for operations that require immediate responses or acknowledgments."}),"\n",(0,r.jsx)(n.h3,{id:"service-architecture",children:"Service Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Services follow a client-server pattern:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Server"}),": Provides functionality and responds to requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Client"}),": Makes requests and waits for responses"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Types"}),": Defined in .srv files with request and response structures"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Pseudocode: Service Implementation\nclass NavigationService:\n    def __init__(self):\n        self.node = rclpy.create_node('navigation_service')\n        self.service = self.node.create_service(\n            nav_msgs.srv.NavigateToPose,\n            'navigate_to_pose',\n            self.handle_navigation_request\n        )\n\n    def handle_navigation_request(self, request, response):\n        # Extract target pose from request\n        target_pose = request.pose\n        navigation_result = self.execute_navigation(target_pose)\n\n        # Set response fields\n        response.success = navigation_result.success\n        response.message = navigation_result.message\n        response.execution_time = navigation_result.execution_time\n\n        return response\n\nclass NavigationClient:\n    def __init__(self):\n        self.node = rclpy.create_node('navigation_client')\n        self.client = self.node.create_client(\n            nav_msgs.srv.NavigateToPose,\n            'navigate_to_pose'\n        )\n\n    def navigate_to_pose(self, target_pose):\n        while not self.client.wait_for_service(timeout_sec=1.0):\n            self.node.get_logger().info('Service not available, waiting...')\n\n        request = nav_msgs.srv.NavigateToPose.Request()\n        request.pose = target_pose\n\n        future = self.client.call_async(request)\n        rclpy.spin_until_future_complete(self.node, future)\n\n        return future.result()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"actions-for-complex-task-management",children:"Actions for Complex Task Management"}),"\n",(0,r.jsx)(n.p,{children:"Actions extend the request-response pattern to handle long-running operations with feedback and goal management."}),"\n",(0,r.jsx)(n.h3,{id:"action-architecture",children:"Action Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Actions support complex operations that may take significant time to complete:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Request to perform a specific task"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Feedback"}),": Continuous updates during task execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Result"}),": Final outcome when task completes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Goal States"}),": Active, Succeeded, Aborted, Canceled"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Pseudocode: Action Server Implementation\nclass MoveRobotAction:\n    def __init__(self):\n        self.node = rclpy.create_node('move_robot_action')\n        self.action_server = ActionServer(\n            self.node,\n            MoveRobot,\n            'move_robot',\n            self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback\n        )\n\n    def goal_callback(self, goal_request):\n        # Validate goal request\n        if self.is_goal_valid(goal_request):\n            return GoalResponse.ACCEPT\n        else:\n            return GoalResponse.REJECT\n\n    def execute_callback(self, goal_handle):\n        feedback_msg = MoveRobot.Feedback()\n        result = MoveRobot.Result()\n\n        # Execute the movement\n        for step in self.generate_movement_steps(goal_handle.request):\n            # Check if goal was canceled\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                result.success = False\n                return result\n\n            # Execute movement step\n            success = self.execute_movement_step(step)\n\n            # Publish feedback\n            feedback_msg.current_distance = self.get_current_distance()\n            feedback_msg.progress_percentage = self.calculate_progress()\n            goal_handle.publish_feedback(feedback_msg)\n\n        # Set final result\n        result.success = success\n        goal_handle.succeed()\n        return result\n"})}),"\n",(0,r.jsx)(n.h2,{id:"urdf-and-robot-description",children:"URDF and Robot Description"}),"\n",(0,r.jsx)(n.p,{children:"URDF (Unified Robot Description Format) provides a standardized way to describe robot kinematics, dynamics, and visual properties."}),"\n",(0,r.jsx)(n.h3,{id:"urdf-structure",children:"URDF Structure"}),"\n",(0,r.jsx)(n.p,{children:"URDF files define robot components using XML:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Links"}),": Rigid bodies with mass, inertia, and visual properties"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Joints"}),": Connections between links with kinematic constraints"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Materials"}),": Visual appearance properties"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gazebo Plugins"}),": Simulation-specific extensions"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Pseudocode: URDF Processing\nclass URDFProcessor:\n    def __init__(self, urdf_file_path):\n        self.urdf_xml = self.load_urdf_file(urdf_file_path)\n        self.links = self.parse_links(self.urdf_xml)\n        self.joints = self.parse_joints(self.urdf_xml)\n        self.materials = self.parse_materials(self.urdf_xml)\n\n    def parse_links(self, urdf_xml):\n        links = {}\n        for link_element in urdf_xml.findall('link'):\n            link = RobotLink()\n            link.name = link_element.get('name')\n            link.inertial = self.parse_inertial(link_element.find('inertial'))\n            link.visual = self.parse_visual(link_element.find('visual'))\n            link.collision = self.parse_collision(link_element.find('collision'))\n            links[link.name] = link\n        return links\n\n    def parse_joints(self, urdf_xml):\n        joints = {}\n        for joint_element in urdf_xml.findall('joint'):\n            joint = RobotJoint()\n            joint.name = joint_element.get('name')\n            joint.type = joint_element.get('type')\n            joint.parent = joint_element.find('parent').get('link')\n            joint.child = joint_element.find('child').get('link')\n            joint.origin = self.parse_origin(joint_element.find('origin'))\n            joint.limit = self.parse_limit(joint_element.find('limit'))\n            joints[joint.name] = joint\n        return joints\n\n    def compute_forward_kinematics(self, joint_angles):\n        # Compute transformation matrices for each joint\n        transforms = {}\n        for joint_name, joint in self.joints.items():\n            joint_angle = joint_angles.get(joint_name, 0.0)\n            transform = self.compute_joint_transform(joint, joint_angle)\n            transforms[joint_name] = transform\n\n        # Combine transforms to get end-effector pose\n        return self.combine_transforms(transforms)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"communication-patterns-and-best-practices",children:"Communication Patterns and Best Practices"}),"\n",(0,r.jsx)(n.p,{children:"Effective ROS 2 development requires understanding appropriate communication patterns for different use cases."}),"\n",(0,r.jsx)(n.h3,{id:"topic-vs-service-vs-action-selection",children:"Topic vs Service vs Action Selection"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Topics for"}),": Sensor data streams, status updates, broadcast messages"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Services for"}),": Quick operations that need immediate responses"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Actions for"}),": Long-running tasks that provide feedback"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"design-patterns",children:"Design Patterns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node Specialization"}),": Each node should have a single, well-defined responsibility"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Message Standardization"}),": Use standard message types when possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Namespace Organization"}),": Organize topics and services using namespaces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Handling"}),": Implement robust error handling and recovery mechanisms"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Pseudocode: Node Design Pattern\nclass ModularNode:\n    def __init__(self, node_name):\n        self.node = rclpy.create_node(node_name)\n\n        # Initialize components\n        self.parameter_handler = ParameterHandler(self.node)\n        self.diagnostics_publisher = self.create_diagnostics_publisher()\n        self.heartbeat_timer = self.create_heartbeat_timer()\n\n        # Initialize communication interfaces\n        self.setup_publishers()\n        self.setup_subscribers()\n        self.setup_services()\n        self.setup_actions()\n\n    def setup_publishers(self):\n        self.status_publisher = self.node.create_publisher(\n            std_msgs.msg.String,\n            'status',\n            10\n        )\n\n    def setup_subscribers(self):\n        self.command_subscriber = self.node.create_subscription(\n            std_msgs.msg.String,\n            'commands',\n            self.command_callback,\n            10\n        )\n\n    def command_callback(self, msg):\n        try:\n            # Process command\n            result = self.process_command(msg.data)\n            self.status_publisher.publish(std_msgs.msg.String(data=result))\n        except Exception as e:\n            self.node.get_logger().error(f'Command processing failed: {e}')\n"})}),"\n",(0,r.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this week, students should be able to:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explain ROS 2 architecture"})," - Describe the node-based architecture, client libraries, and DDS middleware that underpin ROS 2 communication."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implement topic-based communication"})," - Create publishers and subscribers with appropriate QoS profiles for different types of data streams."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Design service-based interactions"})," - Implement request-response communication patterns for operations requiring immediate responses."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Create action-based workflows"})," - Develop long-running operations with feedback and goal management using the action interface."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parse and utilize URDF specifications"})," - Understand and process URDF files to extract robot kinematic and dynamic information for humanoid robot applications."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);